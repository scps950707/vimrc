.TH "std::__debug::bitset" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__debug::bitset \- 
.PP
Class \fBstd::bitset\fP with additional safety/checking/debug instrumentation.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits bitset< _Nb >, and \fB__gnu_debug::_Safe_sequence_base\fP.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbitset\fP (unsigned long long __val)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__str, typename \fBstd::basic_string\fP< _CharT, _Traits, _Alloc >::size_type __pos, typename \fBstd::basic_string\fP< _CharT, _Traits, _Alloc >::size_type __n, _CharT __zero, _CharT __one=_CharT('1'))"
.br
.ti -1c
.RI "\fBbitset\fP (const \fB_Base\fP &__x)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__str, typename \fBstd::basic_string\fP< _CharT, _Traits, _Alloc >::size_type __pos=0, typename \fBstd::basic_string\fP< _CharT, _Traits, _Alloc >::size_type __n=(\fBstd::basic_string\fP< _CharT, _Traits, _Alloc >::npos))"
.br
.ti -1c
.RI "\fBbitset\fP (const char *__str)"
.br
.ti -1c
.RI "\fB_Base\fP & \fB_M_base\fP ()"
.br
.ti -1c
.RI "const \fB_Base\fP & \fB_M_base\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBflip\fP ()"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBflip\fP (size_t __pos)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBbitset\fP< _Nb > &__rhs) const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator&=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator<<\fP (size_t __pos) const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator<<=\fP (size_t __pos)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBbitset\fP< _Nb > &__rhs) const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator>>\fP (size_t __pos) const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator>>=\fP (size_t __pos)"
.br
.ti -1c
.RI "reference \fBoperator[]\fP (size_t __pos)"
.br
.ti -1c
.RI "bool \fBoperator[]\fP (size_t __pos) const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator^=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator|=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator~\fP () const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBreset\fP ()"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBreset\fP (size_t __pos)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBset\fP ()"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBset\fP (size_t __pos, bool __val=true)"
.br
.ti -1c
.RI "\fBstd::basic_string\fP< char, \fBstd::char_traits\fP< char >, \fBstd::allocator\fP< char > > \fBto_string\fP (char __zero, char __one= '1') const "
.br
.ti -1c
.RI "template<typename _CharT > \fBstd::basic_string\fP< _CharT, \fBstd::char_traits\fP< _CharT >, \fBstd::allocator\fP< _CharT > > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBstd::basic_string\fP< _CharT, _Traits, \fBstd::allocator\fP< _CharT > > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<class _CharT > \fBstd::basic_string\fP< _CharT, \fBstd::char_traits\fP< _CharT >, \fBstd::allocator\fP< _CharT > > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "\fBstd::basic_string\fP< char, \fBstd::char_traits\fP< char >, \fBstd::allocator\fP< char > > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits > \fBstd::basic_string\fP< _CharT, _Traits, \fBstd::allocator\fP< _CharT > > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > \fBto_string\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "_Safe_iterator_base * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "_Safe_iterator_base * \fB_M_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (_Safe_sequence_base &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<size_t _Nb> class std::__debug::bitset< _Nb >"
Class \fBstd::bitset\fP with additional safety/checking/debug instrumentation. 
.PP
Definition at line 43 of file debug/bitset.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_all ()\fC [protected, inherited]\fP"Detach all iterators, leaving them singular. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected, inherited]\fP"Detach all singular iterators. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached to this sequence, i->_M_version == _M_version. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()  throw ()\fC [protected, inherited]\fP"For use in \fB_Safe_sequence\fP. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline, inherited]\fP"Invalidates all iterators. 
.PP
Definition at line 215 of file safe_base.h.
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected, inherited]\fP"Revalidates all attached singular iterators. This method may be used to validate iterators that were invalidated before (but for some reason, such as an exception, need to become valid again). 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP & __x)\fC [protected, inherited]\fP"Swap this sequence with the given sequence. This operation also swaps ownership of the iterators, so that when the operation is complete all iterators that originally referenced one container now reference the other container. 
.SH "Member Data Documentation"
.PP 
.SS "_Safe_iterator_base* \fB__gnu_debug::_Safe_sequence_base::_M_const_iterators\fP\fC [inherited]\fP"
.PP
The list of constant iterators that reference this container. 
.PP
Definition at line 166 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "_Safe_iterator_base* \fB__gnu_debug::_Safe_sequence_base::_M_iterators\fP\fC [inherited]\fP"
.PP
The list of mutable iterators that reference this container. 
.PP
Definition at line 163 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "unsigned int \fB__gnu_debug::_Safe_sequence_base::_M_version\fP\fC [mutable, inherited]\fP"
.PP
The container version number. This number may never be 0. 
.PP
Definition at line 169 of file safe_base.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
