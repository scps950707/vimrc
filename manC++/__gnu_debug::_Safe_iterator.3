.TH "__gnu_debug::_Safe_iterator" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_iterator \- 
.PP
Safe iterator wrapper.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fB__gnu_debug::_Safe_iterator_base\fP.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Iterator \fB_Base_iterator\fP"
.br
.ti -1c
.RI "typedef _Traits::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _Traits::iterator_category \fBiterator_category\fP"
.br
.ti -1c
.RI "typedef _Traits::pointer \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Traits::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef _Traits::value_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP (const _Iterator &__i, const _Sequence *__seq)"
.br
.ti -1c
.RI "template<typename _MutableIterator > \fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _MutableIterator, typename __gnu_cxx::__enable_if<(std::__are_same< _MutableIterator, typename _Sequence::iterator::_Base_iterator >::__value), _Sequence >::__type > &__x)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP &__x)"
.br
.ti -1c
.RI "void \fB_M_attach\fP (const _Sequence *__seq)"
.br
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (const _Sequence *__seq)"
.br
.ti -1c
.RI "bool \fB_M_attached_to\fP (const \fB_Safe_sequence_base\fP *__seq) const "
.br
.ti -1c
.RI "bool \fB_M_can_advance\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "_GLIBCXX_PURE bool \fB_M_can_compare\fP (const \fB_Safe_iterator_base\fP &__x) const   throw ()"
.br
.ti -1c
.RI "bool \fB_M_decrementable\fP () const "
.br
.ti -1c
.RI "bool \fB_M_dereferenceable\fP () const "
.br
.ti -1c
.RI "void \fB_M_detach\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP ()  throw ()"
.br
.ti -1c
.RI "const _Sequence * \fB_M_get_sequence\fP () const "
.br
.ti -1c
.RI "bool \fB_M_incrementable\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate\fP ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_single\fP ()"
.br
.ti -1c
.RI "bool \fB_M_is_begin\fP () const "
.br
.ti -1c
.RI "bool \fB_M_is_end\fP () const "
.br
.ti -1c
.RI "_GLIBCXX_PURE bool \fB_M_singular\fP () const   throw ()"
.br
.ti -1c
.RI "template<typename _Other > bool \fB_M_valid_range\fP (const \fB_Safe_iterator\fP< _Other, _Sequence > &__rhs) const "
.br
.ti -1c
.RI "_Iterator \fBbase\fP () const "
.br
.ti -1c
.RI "\fBoperator _Iterator\fP () const "
.br
.ti -1c
.RI "reference \fBoperator*\fP () const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator+\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator+=\fP (const difference_type &__n)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator-\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator--\fP (int)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator--\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator-=\fP (const difference_type &__n)"
.br
.ti -1c
.RI "pointer \fBoperator->\fP () const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator=\fP (const \fB_Safe_iterator\fP &__x)"
.br
.ti -1c
.RI "reference \fBoperator[]\fP (const difference_type &__n) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename _Iterator1 , typename _Iterator2 > static \fBstd::pair\fP< difference_type, _Distance_precision > \fB_M_get_distance\fP (const _Iterator1 &__lhs, const _Iterator2 &__rhs)"
.br
.ti -1c
.RI "template<typename _Iterator1 , typename _Iterator2 > static \fBstd::pair\fP< difference_type, _Distance_precision > \fB_M_get_distance\fP (const _Iterator1 &__lhs, const _Iterator2 &__rhs, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _Iterator1 , typename _Iterator2 > static \fBstd::pair\fP< difference_type, _Distance_precision > \fB_M_get_distance\fP (const _Iterator1 &__lhs, const _Iterator2 &__rhs, \fBstd::random_access_iterator_tag\fP)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_next\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_prior\fP"
.br
.ti -1c
.RI "\fB_Safe_sequence_base\fP * \fB_M_sequence\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Iterator, typename _Sequence> class __gnu_debug::_Safe_iterator< _Iterator, _Sequence >"
Safe iterator wrapper. 

The class template _Safe_iterator is a wrapper around an iterator that tracks the iterator's movement among sequences and checks that operations performed on the 'safe' iterator are legal. In additional to the basic iterator operations (which are validated, and then passed to the underlying iterator), _Safe_iterator has member functions for iterator invalidation, attaching/detaching the iterator from sequences, and querying the iterator's state. 
.PP
Definition at line 63 of file safe_iterator.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP ()\fC [inline]\fP"\fBPostcondition:\fP
.RS 4
the iterator is singular and unattached 
.RE
.PP

.PP
Definition at line 99 of file safe_iterator.h.
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const _Iterator & __i, const _Sequence * __seq)\fC [inline]\fP"
.PP
Safe iterator construction from an unsafe iterator and its sequence. \fBPrecondition:\fP
.RS 4
\fCseq\fP is not NULL 
.RE
.PP
\fBPostcondition:\fP
.RS 4
this is not singular 
.RE
.PP

.PP
Definition at line 108 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator_base::_M_singular().
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > & __x)\fC [inline]\fP"
.PP
Copy construction. 
.PP
Definition at line 119 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator_base::_M_singular().
.SS "template<typename _Iterator, typename _Sequence> template<typename _MutableIterator > \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _MutableIterator, typename __gnu_cxx::__enable_if<(std::__are_same< _MutableIterator, typename _Sequence::iterator::_Base_iterator >::__value), _Sequence >::__type > & __x)\fC [inline]\fP"
.PP
Converting constructor from a mutable iterator to a constant iterator. 
.PP
Definition at line 136 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Iterator, typename _Sequence> void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_attach (const _Sequence * __seq)\fC [inline]\fP"Attach iterator to the given sequence. 
.PP
Definition at line 321 of file safe_iterator.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=().
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach (\fB_Safe_sequence_base\fP * __seq, bool __constant)\fC [inherited]\fP"Attaches this iterator to the given sequence, detaching it from whatever sequence it was attached to originally. If the new sequence is the NULL pointer, the iterator is left unattached. 
.PP
Referenced by __gnu_debug::_Safe_iterator_base::_Safe_iterator_base().
.SS "template<typename _Iterator, typename _Sequence> void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_attach_single (const _Sequence * __seq)\fC [inline]\fP"Likewise, but not thread-safe. 
.PP
Definition at line 329 of file safe_iterator.h.
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach_single (\fB_Safe_sequence_base\fP * __seq, bool __constant)  throw ()\fC [inherited]\fP"Likewise, but not thread-safe. 
.SS "bool __gnu_debug::_Safe_iterator_base::_M_attached_to (const \fB_Safe_sequence_base\fP * __seq) const\fC [inline, inherited]\fP"Determines if we are attached to the given sequence. 
.PP
Definition at line 130 of file safe_base.h.
.PP
References __gnu_debug::_Safe_iterator_base::_M_sequence.
.SS "_GLIBCXX_PURE bool __gnu_debug::_Safe_iterator_base::_M_can_compare (const \fB_Safe_iterator_base\fP & __x) const  throw ()\fC [inherited]\fP"Can we compare this iterator to the given iterator \fC__x\fP? Returns true if both iterators are nonsingular and reference the same sequence. 
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_dereferenceable () const\fC [inline]\fP"
.PP
Is the iterator dereferenceable? 
.PP
Definition at line 345 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_end(), and __gnu_debug::_Safe_iterator_base::_M_singular().
.PP
Referenced by __gnu_debug::__check_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator*(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator->().
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach ()\fC [inherited]\fP"Detach the iterator for whatever sequence it is attached to, if any. 
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach_single ()  throw ()\fC [inherited]\fP"Likewise, but not thread-safe. 
.SS "template<typename _Iterator, typename _Sequence> template<typename _Iterator1 , typename _Iterator2 > static \fBstd::pair\fP<difference_type, _Distance_precision> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_get_distance (const _Iterator1 & __lhs, const _Iterator2 & __rhs)\fC [inline, static]\fP"Determine the distance between two iterators with some known precision. 
.PP
Definition at line 375 of file safe_iterator.h.
.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_iterator_base::_M_get_mutex ()  throw ()\fC [protected, inherited]\fP"For use in \fB_Safe_iterator\fP. 
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate().
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_incrementable () const\fC [inline]\fP"
.PP
Is the iterator incrementable? 
.PP
Definition at line 350 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator++().
.SS "template<typename _Iterator , typename _Sequence > void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_invalidate ()"Invalidate the iterator, making it singular. 
.PP
Definition at line 106 of file safe_iterator.tcc.
.PP
References __gnu_debug::_Safe_iterator_base::_M_get_mutex(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single().
.SS "template<typename _Iterator , typename _Sequence > void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_invalidate_single ()"Likewise, but not thread-safe. 
.PP
Definition at line 115 of file safe_iterator.tcc.
.PP
References __gnu_debug::_Safe_sequence_base::_M_const_iterators, __gnu_debug::_Safe_sequence_base::_M_iterators, __gnu_debug::_Safe_iterator_base::_M_next, __gnu_debug::_Safe_iterator_base::_M_sequence, __gnu_debug::_Safe_iterator_base::_M_singular(), __gnu_debug::_Safe_iterator_base::_M_version, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::base().
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate().
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_is_begin () const\fC [inline]\fP"
.PP
Is this iterator equal to the sequence's begin() iterator? 
.PP
Definition at line 400 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator_base::_M_sequence.
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_is_end () const\fC [inline]\fP"
.PP
Is this iterator equal to the sequence's end() iterator? 
.PP
Definition at line 404 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator_base::_M_sequence.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.SS "_GLIBCXX_PURE bool __gnu_debug::_Safe_iterator_base::_M_singular () const  throw ()\fC [inherited]\fP"Is this iterator singular? 
.PP
Referenced by __gnu_debug::__check_singular(), __gnu_debug::__check_singular_aux(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_Safe_iterator(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=().
.SS "template<typename _Iterator, typename _Sequence> _Iterator \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::base () const\fC [inline]\fP"
.PP
Return the underlying iterator. 
.PP
Definition at line 311 of file safe_iterator.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator _Iterator () const\fC [inline]\fP"
.PP
Conversion to underlying non-debug iterator to allow better interaction with non-debug containers. 
.PP
Definition at line 317 of file safe_iterator.h.
.SS "template<typename _Iterator, typename _Sequence> reference \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator* () const\fC [inline]\fP"
.PP
Iterator dereference. \fBPrecondition:\fP
.RS 4
iterator is dereferenceable 
.RE
.PP

.PP
Definition at line 175 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator++ (int)\fC [inline]\fP"
.PP
Iterator postincrement. \fBPrecondition:\fP
.RS 4
iterator is incrementable 
.RE
.PP

.PP
Definition at line 218 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable().
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator++ ()\fC [inline]\fP"
.PP
Iterator preincrement. \fBPrecondition:\fP
.RS 4
iterator is incrementable 
.RE
.PP

.PP
Definition at line 204 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable().
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-- (int)\fC [inline]\fP"
.PP
Iterator postdecrement. \fBPrecondition:\fP
.RS 4
iterator is decrementable 
.RE
.PP

.PP
Definition at line 248 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY.
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-- ()\fC [inline]\fP"
.PP
Iterator predecrement. \fBPrecondition:\fP
.RS 4
iterator is decrementable 
.RE
.PP

.PP
Definition at line 234 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY.
.SS "template<typename _Iterator, typename _Sequence> pointer \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-> () const\fC [inline]\fP"
.PP
Iterator dereference. \fBPrecondition:\fP
.RS 4
iterator is dereferenceable 
.RE
.PP
\fBTodo\fP
.RS 4
Make this correct w.r.t. iterators that return proxies 
.PP
Use addressof() instead of & operator 
.RE
.PP

.PP
Definition at line 190 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator= (const \fB_Safe_iterator\fP< _Iterator, _Sequence > & __x)\fC [inline]\fP"
.PP
Copy assignment. 
.PP
Definition at line 156 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach(), __gnu_debug::_Safe_iterator_base::_M_sequence, and __gnu_debug::_Safe_iterator_base::_M_singular().
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_next\fP\fC [inherited]\fP"Pointer to the next iterator in the sequence's list of iterators. Only valid when _M_sequence != NULL. 
.PP
Definition at line 73 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single().
.SS "\fB_Safe_iterator_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_prior\fP\fC [inherited]\fP"Pointer to the previous iterator in the sequence's list of iterators. Only valid when _M_sequence != NULL. 
.PP
Definition at line 69 of file safe_base.h.
.SS "\fB_Safe_sequence_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_sequence\fP\fC [inherited]\fP"The sequence this iterator references; may be NULL to indicate a singular iterator. 
.PP
Definition at line 56 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_iterator_base::_M_attached_to(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_begin(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_end(), __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter(), __gnu_debug::_Safe_iterator_base::_Safe_iterator_base(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=().
.SS "unsigned int \fB__gnu_debug::_Safe_iterator_base::_M_version\fP\fC [inherited]\fP"The version number of this iterator. The sentinel value 0 is used to indicate an invalidated iterator (i.e., one that is singular because of an operation on the container). This version number must equal the version number in the sequence referenced by _M_sequence for the iterator to be non-singular. 
.PP
Definition at line 65 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
