.TH "std::map" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::map \- 
.PP
A standard container made up of (key,value) pairs, which can be retrieved based on a key, in logarithmic time.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef _Rep_type::const_iterator \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Pair_alloc_type::const_pointer \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Pair_alloc_type::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fB_Rep_type::const_reverse_iterator\fP \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Rep_type::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _Rep_type::iterator \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Compare \fBkey_compare\fP"
.br
.ti -1c
.RI "typedef _Key \fBkey_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBmapped_type\fP"
.br
.ti -1c
.RI "typedef _Pair_alloc_type::pointer \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Pair_alloc_type::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fB_Rep_type::reverse_iterator\fP \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Rep_type::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fBstd::pair\fP< const _Key, _Tp > \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBmap\fP ()"
.br
.ti -1c
.RI "\fBmap\fP (const _Compare &__comp, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBmap\fP (\fBmap\fP &&__x)"
.br
.ti -1c
.RI "\fBmap\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l, const _Compare &__c=_Compare(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBmap\fP (const \fBmap\fP &__x)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBmap\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBmap\fP (_InputIterator __first, _InputIterator __last, const _Compare &__comp, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "mapped_type & \fBat\fP (const key_type &__k)"
.br
.ti -1c
.RI "const mapped_type & \fBat\fP (const key_type &__k) const "
.br
.ti -1c
.RI "iterator \fBbegin\fP ()"
.br
.ti -1c
.RI "const_iterator \fBbegin\fP () const "
.br
.ti -1c
.RI "const_iterator \fBcbegin\fP () const "
.br
.ti -1c
.RI "const_iterator \fBcend\fP () const "
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "size_type \fBcount\fP (const key_type &__x) const "
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const "
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "iterator \fBend\fP ()"
.br
.ti -1c
.RI "const_iterator \fBend\fP () const "
.br
.ti -1c
.RI "\fBstd::pair\fP< const_iterator, const_iterator > \fBequal_range\fP (const key_type &__x) const "
.br
.ti -1c
.RI "\fBstd::pair\fP< iterator, iterator > \fBequal_range\fP (const key_type &__x)"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __position)"
.br
.ti -1c
.RI "size_type \fBerase\fP (const key_type &__x)"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __first, iterator __last)"
.br
.ti -1c
.RI "iterator \fBfind\fP (const key_type &__x)"
.br
.ti -1c
.RI "const_iterator \fBfind\fP (const key_type &__x) const "
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const "
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "\fBstd::pair\fP< iterator, bool > \fBinsert\fP (const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBstd::initializer_list\fP< \fBvalue_type\fP > __list)"
.br
.ti -1c
.RI "key_compare \fBkey_comp\fP () const "
.br
.ti -1c
.RI "const_iterator \fBlower_bound\fP (const key_type &__x) const "
.br
.ti -1c
.RI "iterator \fBlower_bound\fP (const key_type &__x)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const "
.br
.ti -1c
.RI "\fBmap\fP & \fBoperator=\fP (\fBmap\fP &&__x)"
.br
.ti -1c
.RI "\fBmap\fP & \fBoperator=\fP (const \fBmap\fP &__x)"
.br
.ti -1c
.RI "\fBmap\fP & \fBoperator=\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l)"
.br
.ti -1c
.RI "mapped_type & \fBoperator[]\fP (const key_type &__k)"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const "
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP ()"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const "
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "void \fBswap\fP (\fBmap\fP &__x)"
.br
.ti -1c
.RI "iterator \fBupper_bound\fP (const key_type &__x)"
.br
.ti -1c
.RI "const_iterator \fBupper_bound\fP (const key_type &__x) const "
.br
.ti -1c
.RI "value_compare \fBvalue_comp\fP () const "
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _K1 , typename _T1 , typename _C1 , typename _A1 > bool \fBoperator<\fP (const \fBmap\fP< _K1, _T1, _C1, _A1 > &, const \fBmap\fP< _K1, _T1, _C1, _A1 > &)"
.br
.ti -1c
.RI "template<typename _K1 , typename _T1 , typename _C1 , typename _A1 > bool \fBoperator==\fP (const \fBmap\fP< _K1, _T1, _C1, _A1 > &, const \fBmap\fP< _K1, _T1, _C1, _A1 > &)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> class std::map< _Key, _Tp, _Compare, _Alloc >"
A standard container made up of (key,value) pairs, which can be retrieved based on a key, in logarithmic time. 

Meets the requirements of a \fCcontainer\fP, a \fCreversible container\fP, and an \fCassociative container\fP (using unique keys). For a \fCmap<Key,T>\fP the key_type is Key, the mapped_type is T, and the value_type is std::pair<const Key,T>.
.PP
Maps support bidirectional iterators.
.PP
The private tree data is declared exactly the same way for map and multimap; the distinction is made entirely in how the tree functions are called (*_unique versus *_equal, same as the standard). 
.PP
Definition at line 86 of file stl_map.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP ()\fC [inline]\fP"
.PP
Default constructor creates no elements. 
.PP
Definition at line 150 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (const _Compare & __comp, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline, explicit]\fP"
.PP
Creates a map with no elements. \fBParameters:\fP
.RS 4
\fIcomp\fP A comparison object. 
.br
\fIa\fP An allocator object. 
.RE
.PP

.PP
Definition at line 159 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > & __x)\fC [inline]\fP"
.PP
Map copy constructor. \fBParameters:\fP
.RS 4
\fIx\fP A map of identical element and allocator types.
.RE
.PP
The newly-created map uses a copy of the allocation object used by \fIx\fP. 
.PP
Definition at line 170 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > && __x)\fC [inline]\fP"
.PP
Map move constructor. \fBParameters:\fP
.RS 4
\fIx\fP A map of identical element and allocator types.
.RE
.PP
The newly-created map contains the exact contents of \fIx\fP. The contents of \fIx\fP are a valid, but unspecified map. 
.PP
Definition at line 181 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l, const _Compare & __c = \fC_Compare()\fP, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline]\fP"
.PP
Builds a map from an \fBinitializer_list\fP. \fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP. 
.br
\fIcomp\fP A comparison object. 
.br
\fIa\fP An allocator object.
.RE
.PP
Create a map consisting of copies of the elements in the \fBinitializer_list\fP \fIl\fP. This is linear in N if the range is already sorted, and NlogN otherwise (where N is \fIl.size()\fP). 
.PP
Definition at line 195 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _InputIterator > \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (_InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
Builds a map from a range. \fBParameters:\fP
.RS 4
\fIfirst\fP An input iterator. 
.br
\fIlast\fP An input iterator.
.RE
.PP
Create a map consisting of copies of the elements from [first,last). This is linear in N if the range is already sorted, and NlogN otherwise (where N is distance(first,last)). 
.PP
Definition at line 212 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _InputIterator > \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (_InputIterator __first, _InputIterator __last, const _Compare & __comp, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline]\fP"
.PP
Builds a map from a range. \fBParameters:\fP
.RS 4
\fIfirst\fP An input iterator. 
.br
\fIlast\fP An input iterator. 
.br
\fIcomp\fP A comparison functor. 
.br
\fIa\fP An allocator object.
.RE
.PP
Create a map consisting of copies of the elements from [first,last). This is linear in N if the range is already sorted, and NlogN otherwise (where N is distance(first,last)). 
.PP
Definition at line 228 of file stl_map.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> mapped_type& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::at (const key_type & __k)\fC [inline]\fP"
.PP
Access to map data. \fBParameters:\fP
.RS 4
\fIk\fP The key for which data should be retrieved. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference to the data whose key is equivalent to \fIk\fP, if such a data is present in the map. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If no such data is present. 
.RE
.PP

.PP
Definition at line 465 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::begin ()\fC [inline]\fP"Returns a read/write iterator that points to the first pair in the map. Iteration is done in ascending order according to the keys. 
.PP
Definition at line 307 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::begin () const\fC [inline]\fP"Returns a read-only (constant) iterator that points to the first pair in the map. Iteration is done in ascending order according to the keys. 
.PP
Definition at line 316 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::cbegin () const\fC [inline]\fP"Returns a read-only (constant) iterator that points to the first pair in the map. Iteration is done in ascending order according to the keys. 
.PP
Definition at line 380 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::cend () const\fC [inline]\fP"Returns a read-only (constant) iterator that points one past the last pair in the map. Iteration is done in ascending order according to the keys. 
.PP
Definition at line 389 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::clear ()\fC [inline]\fP"Erases all elements in a map. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 663 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> size_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::count (const key_type & __x) const\fC [inline]\fP"
.PP
Finds the number of elements with given key. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pairs to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of elements with specified key.
.RE
.PP
This function only makes sense for multimaps; for map the result will either be 0 (not present) or 1 (present). 
.PP
Definition at line 723 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_reverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::crbegin () const\fC [inline]\fP"Returns a read-only (constant) reverse iterator that points to the last pair in the map. Iteration is done in descending order according to the keys. 
.PP
Definition at line 398 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_reverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::crend () const\fC [inline]\fP"Returns a read-only (constant) reverse iterator that points to one before the first pair in the map. Iteration is done in descending order according to the keys. 
.PP
Definition at line 407 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> bool \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::empty () const\fC [inline]\fP"Returns true if the map is empty. (Thus \fBbegin()\fP would equal \fBend()\fP.) 
.PP
Definition at line 416 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::end () const\fC [inline]\fP"Returns a read-only (constant) iterator that points one past the last pair in the map. Iteration is done in ascending order according to the keys. 
.PP
Definition at line 334 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::end ()\fC [inline]\fP"Returns a read/write iterator that points one past the last pair in the map. Iteration is done in ascending order according to the keys. 
.PP
Definition at line 325 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<iterator, iterator> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::equal_range (const key_type & __x)\fC [inline]\fP"
.PP
Finds a subsequence matching given key. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pairs to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pair of iterators that possibly points to the subsequence matching given key.
.RE
.PP
This function is equivalent to 
.PP
.nf
    std::make_pair(c.lower_bound(val),
                   c.upper_bound(val))

.fi
.PP
 (but is faster than making the calls separately).
.PP
This function probably only makes sense for multimaps. 
.PP
Definition at line 792 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<const_iterator, const_iterator> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::equal_range (const key_type & __x) const\fC [inline]\fP"
.PP
Finds a subsequence matching given key. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pairs to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pair of read-only (constant) iterators that possibly points to the subsequence matching given key.
.RE
.PP
This function is equivalent to 
.PP
.nf
    std::make_pair(c.lower_bound(val),
                   c.upper_bound(val))

.fi
.PP
 (but is faster than making the calls separately).
.PP
This function probably only makes sense for multimaps. 
.PP
Definition at line 811 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::erase (iterator __position)\fC [inline]\fP"
.PP
Erases an element from a map. \fBParameters:\fP
.RS 4
\fIposition\fP An iterator pointing to the element to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointing to the element immediately following \fIposition\fP prior to the element being erased. If no such element exists, \fBend()\fP is returned.
.RE
.PP
This function erases an element, pointed to by the given iterator, from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 573 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> size_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::erase (const key_type & __x)\fC [inline]\fP"
.PP
Erases elements according to the provided key. \fBParameters:\fP
.RS 4
\fIx\fP Key of element to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of elements erased.
.RE
.PP
This function erases all the elements located by the given key from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 603 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::erase (iterator __first, iterator __last)\fC [inline]\fP"
.PP
Erases a [first,last) range of elements from a map. \fBParameters:\fP
.RS 4
\fIfirst\fP Iterator pointing to the start of the range to be erased. 
.br
\fIlast\fP Iterator pointing to the end of the range to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
The iterator \fIlast\fP.
.RE
.PP
This function erases a sequence of elements from a map. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 622 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::find (const key_type & __x) const\fC [inline]\fP"
.PP
Tries to locate an element in a map. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pair to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) iterator pointing to sought-after element, or \fBend()\fP if not found.
.RE
.PP
This function takes a key and tries to locate the element with which the key matches. If successful the function returns a constant iterator pointing to the sought after pair. If unsuccessful it returns the past-the-end ( \fC\fBend()\fP\fP ) iterator. 
.PP
Definition at line 711 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::find (const key_type & __x)\fC [inline]\fP"
.PP
Tries to locate an element in a map. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pair to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointing to sought-after element, or \fBend()\fP if not found.
.RE
.PP
This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after pair. If unsuccessful it returns the past-the-end ( \fC\fBend()\fP\fP ) iterator. 
.PP
Definition at line 696 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> allocator_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::get_allocator () const\fC [inline]\fP"
.PP
Get a copy of the memory allocation object. 
.PP
Definition at line 297 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<iterator, bool> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::insert (const \fBvalue_type\fP & __x)\fC [inline]\fP"
.PP
Attempts to insert a \fBstd::pair\fP into the map. \fBParameters:\fP
.RS 4
\fIx\fP Pair to be inserted (see std::make_pair for easy creation of pairs).
.RE
.PP
\fBReturns:\fP
.RS 4
A pair, of which the first element is an iterator that points to the possibly inserted pair, and the second is a bool that is true if the pair was actually inserted.
.RE
.PP
This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a pair is only inserted if its first element (the key) is not already present in the map.
.PP
Insertion requires logarithmic time. 
.PP
Definition at line 500 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::insert (\fBstd::initializer_list\fP< \fBvalue_type\fP > __list)\fC [inline]\fP"
.PP
Attempts to insert a list of std::pairs into the map. \fBParameters:\fP
.RS 4
\fIlist\fP A std::initializer_list<value_type> of pairs to be inserted.
.RE
.PP
Complexity similar to that of the range constructor. 
.PP
Definition at line 512 of file stl_map.h.
.PP
References std::map< _Key, _Tp, _Compare, _Alloc >::insert().
.PP
Referenced by std::map< _Key, _Tp, _Compare, _Alloc >::insert().
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::insert (iterator __position, const \fBvalue_type\fP & __x)\fC [inline]\fP"
.PP
Attempts to insert a \fBstd::pair\fP into the map. \fBParameters:\fP
.RS 4
\fIposition\fP An iterator that serves as a hint as to where the pair should be inserted. 
.br
\fIx\fP Pair to be inserted (see std::make_pair for easy creation of pairs). 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator that points to the element with key of \fIx\fP (may or may not be the pair passed in).
.RE
.PP
This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument \fBinsert()\fP does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.
.PP
See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html for more on \fIhinting\fP.
.PP
Insertion requires logarithmic time (if the hint is not taken). 
.PP
Definition at line 540 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _InputIterator > void \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::insert (_InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
Template function that attempts to insert a range of elements. \fBParameters:\fP
.RS 4
\fIfirst\fP Iterator pointing to the start of the range to be inserted. 
.br
\fIlast\fP Iterator pointing to the end of the range.
.RE
.PP
Complexity similar to that of the range constructor. 
.PP
Definition at line 553 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> key_compare \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::key_comp () const\fC [inline]\fP"Returns the key comparison object out of which the map was constructed. 
.PP
Definition at line 672 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::lower_bound (const key_type & __x)\fC [inline]\fP"
.PP
Finds the beginning of a subsequence matching given key. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pair to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointing to first element equal to or greater than key, or \fBend()\fP.
.RE
.PP
This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or \fBend()\fP if no such element exists. 
.PP
Definition at line 738 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::lower_bound (const key_type & __x) const\fC [inline]\fP"
.PP
Finds the beginning of a subsequence matching given key. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pair to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) iterator pointing to first element equal to or greater than key, or \fBend()\fP.
.RE
.PP
This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or \fBend()\fP if no such element exists. 
.PP
Definition at line 753 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> size_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::max_size () const\fC [inline]\fP"Returns the maximum size of the map. 
.PP
Definition at line 426 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmap\fP& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::operator= (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > && __x)\fC [inline]\fP"
.PP
Map move assignment operator. \fBParameters:\fP
.RS 4
\fIx\fP A map of identical element and allocator types.
.RE
.PP
The contents of \fIx\fP are moved into this map (without copying). \fIx\fP is a valid, but unspecified map. 
.PP
Definition at line 266 of file stl_map.h.
.PP
References std::swap().
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmap\fP& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::operator= (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > & __x)\fC [inline]\fP"
.PP
Map assignment operator. The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A map of identical element and allocator types.
.RE
.PP
All the elements of \fIx\fP are copied, but unlike the copy constructor, the allocator object is not copied. 
.PP
Definition at line 251 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmap\fP& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::operator= (\fBinitializer_list\fP< \fBvalue_type\fP > __l)\fC [inline]\fP"
.PP
Map list assignment operator. \fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP.
.RE
.PP
This function fills a map with copies of the elements in the initializer list \fIl\fP.
.PP
Note that the assignment completely changes the map and that the resulting map's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 287 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> mapped_type& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::operator[] (const key_type & __k)\fC [inline]\fP"
.PP
Subscript ( \fC\fP[] ) access to map data. \fBParameters:\fP
.RS 4
\fIk\fP The key for which data should be retrieved. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference to the data of the (key,data) pair.
.RE
.PP
Allows for easy lookup with the subscript ( \fC\fP[] ) operator. Returns data associated with the key specified in subscript. If the key does not exist, a pair with that key is created using default values, which is then returned.
.PP
Lookup requires logarithmic time. 
.PP
Definition at line 443 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBreverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::rbegin ()\fC [inline]\fP"Returns a read/write reverse iterator that points to the last pair in the map. Iteration is done in descending order according to the keys. 
.PP
Definition at line 343 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_reverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::rbegin () const\fC [inline]\fP"Returns a read-only (constant) reverse iterator that points to the last pair in the map. Iteration is done in descending order according to the keys. 
.PP
Definition at line 352 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_reverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::rend () const\fC [inline]\fP"Returns a read-only (constant) reverse iterator that points to one before the first pair in the map. Iteration is done in descending order according to the keys. 
.PP
Definition at line 370 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBreverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::rend ()\fC [inline]\fP"Returns a read/write reverse iterator that points to one before the first pair in the map. Iteration is done in descending order according to the keys. 
.PP
Definition at line 361 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> size_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::size () const\fC [inline]\fP"Returns the size of the map. 
.PP
Definition at line 421 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::swap (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > & __x)\fC [inline]\fP"
.PP
Swaps data with another map. \fBParameters:\fP
.RS 4
\fIx\fP A map of the same element and allocator types.
.RE
.PP
This exchanges the elements between two maps in constant time. (It is only swapping a pointer, an integer, and an instance of the \fCCompare\fP type (which itself is often stateless and empty), so it should be quite fast.) Note that the global \fBstd::swap()\fP function is specialized such that std::swap(m1,m2) will feed to this function. 
.PP
Definition at line 653 of file stl_map.h.
.PP
Referenced by std::swap().
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::upper_bound (const key_type & __x) const\fC [inline]\fP"
.PP
Finds the end of a subsequence matching given key. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pair to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) iterator pointing to first iterator greater than key, or \fBend()\fP. 
.RE
.PP

.PP
Definition at line 773 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::upper_bound (const key_type & __x)\fC [inline]\fP"
.PP
Finds the end of a subsequence matching given key. \fBParameters:\fP
.RS 4
\fIx\fP Key of (key, value) pair to be located. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointing to the first element greater than key, or \fBend()\fP. 
.RE
.PP

.PP
Definition at line 763 of file stl_map.h.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> value_compare \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::value_comp () const\fC [inline]\fP"Returns a value comparison object, built from the key comparison object out of which the map was constructed. 
.PP
Definition at line 680 of file stl_map.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
