.TH "std::__debug::list" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__debug::list \- 
.PP
Class \fBstd::list\fP with safety/checking/debug instrumentation.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits list< _Tp, _Allocator >, and \fB_Safe_sequence< list< _Tp, _Allocator > >\fP.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Allocator \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fB__gnu_debug::_Safe_iterator\fP< typename \fB_Base::const_iterator\fP, \fBlist\fP > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::const_pointer \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Base::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< \fBconst_iterator\fP > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fB__gnu_debug::_Safe_iterator\fP< typename \fB_Base::iterator\fP, \fBlist\fP > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Base::pointer \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Base::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< \fBiterator\fP > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBlist\fP (const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBlist\fP (size_type __n, const _Tp &__value=_Tp(), const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBlist\fP (const \fBlist\fP &__x)"
.br
.ti -1c
.RI "\fBlist\fP (const \fB_Base\fP &__x)"
.br
.ti -1c
.RI "template<class _InputIterator > \fBlist\fP (_InputIterator __first, _InputIterator __last, const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBlist\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "\fBlist\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fB_Base\fP & \fB_M_base\fP ()"
.br
.ti -1c
.RI "const \fB_Base\fP & \fB_M_base\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "void \fB_M_transfer_iter\fP (const _Safe_iterator< _Iterator, \fBlist\fP< _Tp, _Allocator > > &__x)"
.br
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "template<class _InputIterator > void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const _Tp &__t)"
.br
.ti -1c
.RI "const_reference \fBback\fP () const "
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const "
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const "
.br
.ti -1c
.RI "template<typename... _Args> \fBiterator\fP \fBemplace\fP (\fBiterator\fP __position, _Args &&...__args)"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __position, \fBiterator\fP __last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "template<class _InputIterator > void \fBinsert\fP (\fBiterator\fP __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, const _Tp &__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, _Tp &&__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, \fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __position, size_type __n, const _Tp &__x)"
.br
.ti -1c
.RI "void \fBmerge\fP (\fBlist\fP &__x)"
.br
.ti -1c
.RI "void \fBmerge\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "template<class _Compare > void \fBmerge\fP (\fBlist\fP &&__x, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Compare > void \fBmerge\fP (\fBlist\fP &__x, _Compare __comp)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (const \fBlist\fP &__x)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpop_front\fP ()"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const "
.br
.ti -1c
.RI "void \fBremove\fP (const _Tp &__value)"
.br
.ti -1c
.RI "template<class _Predicate > void \fBremove_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const "
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP ()"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __sz, _Tp __c=_Tp())"
.br
.ti -1c
.RI "void \fBsort\fP ()"
.br
.ti -1c
.RI "template<typename _StrictWeakOrdering > void \fBsort\fP (_StrictWeakOrdering __pred)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &__x, \fBiterator\fP __i)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x, \fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &__x, \fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &__x)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x, \fBiterator\fP __i)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBlist\fP &__x)"
.br
.ti -1c
.RI "template<class _BinaryPredicate > void \fBunique\fP (_BinaryPredicate __binary_pred)"
.br
.ti -1c
.RI "void \fBunique\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "_Safe_iterator_base * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "_Safe_iterator_base * \fB_M_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (_Safe_sequence_base &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Allocator = std::allocator<_Tp>> class std::__debug::list< _Tp, _Allocator >"
Class \fBstd::list\fP with safety/checking/debug instrumentation. 
.PP
Definition at line 43 of file debug/list.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_all ()\fC [protected, inherited]\fP"Detach all iterators, leaving them singular. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected, inherited]\fP"Detach all singular iterators. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached to this sequence, i->_M_version == _M_version. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()  throw ()\fC [protected, inherited]\fP"For use in \fB_Safe_sequence\fP. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline, inherited]\fP"Invalidates all iterators. 
.PP
Definition at line 215 of file safe_base.h.
.SS "void \fB__gnu_debug::_Safe_sequence\fP< \fBlist\fP< _Tp, _Allocator >  >::_M_invalidate_if (_Predicate __pred)\fC [inherited]\fP"Invalidates all iterators \fCx\fP that reference this sequence, are not singular, and for which \fCpred(x)\fP returns \fCtrue\fP. The user of this routine should be careful not to make copies of the iterators passed to \fCpred\fP, as the copies may interfere with the invalidation. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected, inherited]\fP"Revalidates all attached singular iterators. This method may be used to validate iterators that were invalidated before (but for some reason, such as an exception, need to become valid again). 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP & __x)\fC [protected, inherited]\fP"Swap this sequence with the given sequence. This operation also swaps ownership of the iterators, so that when the operation is complete all iterators that originally referenced one container now reference the other container. 
.SS "void \fB__gnu_debug::_Safe_sequence\fP< \fBlist\fP< _Tp, _Allocator >  >::_M_transfer_iter (const \fB_Safe_iterator\fP< _Iterator, \fBlist\fP< _Tp, _Allocator >  > & __x)\fC [inherited]\fP"Transfers all iterators that reference this memory location to this sequence from whatever sequence they are attached to. 
.SH "Member Data Documentation"
.PP 
.SS "_Safe_iterator_base* \fB__gnu_debug::_Safe_sequence_base::_M_const_iterators\fP\fC [inherited]\fP"
.PP
The list of constant iterators that reference this container. 
.PP
Definition at line 166 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "_Safe_iterator_base* \fB__gnu_debug::_Safe_sequence_base::_M_iterators\fP\fC [inherited]\fP"
.PP
The list of mutable iterators that reference this container. 
.PP
Definition at line 163 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "unsigned int \fB__gnu_debug::_Safe_sequence_base::_M_version\fP\fC [mutable, inherited]\fP"
.PP
The container version number. This number may never be 0. 
.PP
Definition at line 169 of file safe_base.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
