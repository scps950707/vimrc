.TH "std::bitset" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::bitset \- 
.PP
The bitset class represents a \fIfixed-size\fP sequence of bits.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fB_Base_bitset<((_Nb)< 1?0:((_Nb)+(__CHAR_BIT__ *sizeof(unsigned long))-1)/(__CHAR_BIT__ *sizeof(unsigned long)))>\fP.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBreference\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbitset\fP ()"
.br
.ti -1c
.RI "\fBbitset\fP (unsigned long long __val)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __position, size_t __n)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __position, size_t __n, _CharT __zero, _CharT __one=_CharT('1'))"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __position=0)"
.br
.ti -1c
.RI "\fBbitset\fP (const char *__str)"
.br
.ti -1c
.RI "size_t \fB_Find_first\fP () const "
.br
.ti -1c
.RI "size_t \fB_Find_next\fP (size_t __prev) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits > void \fB_M_copy_from_ptr\fP (const _CharT *, size_t, size_t, size_t, _CharT, _CharT)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > void \fB_M_copy_from_string\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __pos, size_t __n, _CharT __zero, _CharT __one)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > void \fB_M_copy_from_string\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __pos, size_t __n)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > void \fB_M_copy_to_string\fP (\fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &, _CharT, _CharT) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > void \fB_M_copy_to_string\fP (\fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s) const "
.br
.ti -1c
.RI "bool \fBall\fP () const "
.br
.ti -1c
.RI "bool \fBany\fP () const "
.br
.ti -1c
.RI "size_t \fBcount\fP () const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBflip\fP ()"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBflip\fP (size_t __position)"
.br
.ti -1c
.RI "bool \fBnone\fP () const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator~\fP () const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBreset\fP ()"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBreset\fP (size_t __position)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBset\fP ()"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBset\fP (size_t __position, bool __val=true)"
.br
.ti -1c
.RI "size_t \fBsize\fP () const "
.br
.ti -1c
.RI "bool \fBtest\fP (size_t __position) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits > \fBstd::basic_string\fP< _CharT, _Traits, \fBstd::allocator\fP< _CharT > > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<class _CharT > \fBstd::basic_string\fP< _CharT, \fBstd::char_traits\fP< _CharT >, \fBstd::allocator\fP< _CharT > > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<class _CharT > \fBstd::basic_string\fP< _CharT, \fBstd::char_traits\fP< _CharT >, \fBstd::allocator\fP< _CharT > > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits > \fBstd::basic_string\fP< _CharT, _Traits, \fBstd::allocator\fP< _CharT > > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "\fBstd::basic_string\fP< char, \fBstd::char_traits\fP< char >, \fBstd::allocator\fP< char > > \fBto_string\fP (char __zero, char __one= '1') const "
.br
.ti -1c
.RI "\fBstd::basic_string\fP< char, \fBstd::char_traits\fP< char >, \fBstd::allocator\fP< char > > \fBto_string\fP () const "
.br
.ti -1c
.RI "unsigned long long \fBto_ullong\fP () const "
.br
.ti -1c
.RI "unsigned long \fBto_ulong\fP () const "
.br
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator&=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator|=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator^=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator<<=\fP (size_t __position)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator>>=\fP (size_t __position)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fB_Unchecked_set\fP (size_t __pos)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fB_Unchecked_set\fP (size_t __pos, int __val)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fB_Unchecked_reset\fP (size_t __pos)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fB_Unchecked_flip\fP (size_t __pos)"
.br
.ti -1c
.RI "bool \fB_Unchecked_test\fP (size_t __pos) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBreference\fP \fBoperator[]\fP (size_t __position)"
.br
.ti -1c
.RI "bool \fBoperator[]\fP (size_t __position) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "bool \fBoperator==\fP (const \fBbitset\fP< _Nb > &__rhs) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBbitset\fP< _Nb > &__rhs) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator<<\fP (size_t __position) const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator>>\fP (size_t __position) const "
.br
.in -1c
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef unsigned long \fB_WordT\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "size_t \fB_M_are_all_aux\fP () const"
.br
.ti -1c
.RI "void \fB_M_do_and\fP (const \fB_Base_bitset\fP< _Nw > &__x)"
.br
.ti -1c
.RI "size_t \fB_M_do_count\fP () const"
.br
.ti -1c
.RI "size_t \fB_M_do_find_first\fP (size_t __not_found) const"
.br
.ti -1c
.RI "size_t \fB_M_do_find_next\fP (size_t __prev, size_t __not_found) const"
.br
.ti -1c
.RI "void \fB_M_do_flip\fP ()"
.br
.ti -1c
.RI "void \fB_M_do_left_shift\fP (size_t __shift)"
.br
.ti -1c
.RI "void \fB_M_do_or\fP (const \fB_Base_bitset\fP< _Nw > &__x)"
.br
.ti -1c
.RI "void \fB_M_do_reset\fP ()"
.br
.ti -1c
.RI "void \fB_M_do_right_shift\fP (size_t __shift)"
.br
.ti -1c
.RI "void \fB_M_do_set\fP ()"
.br
.ti -1c
.RI "unsigned long long \fB_M_do_to_ullong\fP () const"
.br
.ti -1c
.RI "unsigned long \fB_M_do_to_ulong\fP () const"
.br
.ti -1c
.RI "void \fB_M_do_xor\fP (const \fB_Base_bitset\fP< _Nw > &__x)"
.br
.ti -1c
.RI "const _WordT * \fB_M_getdata\fP () const"
.br
.ti -1c
.RI "_WordT \fB_M_getword\fP (size_t __pos) const"
.br
.ti -1c
.RI "_WordT & \fB_M_getword\fP (size_t __pos)"
.br
.ti -1c
.RI "_WordT & \fB_M_hiword\fP ()"
.br
.ti -1c
.RI "_WordT \fB_M_hiword\fP () const"
.br
.ti -1c
.RI "bool \fB_M_is_any\fP () const"
.br
.ti -1c
.RI "bool \fB_M_is_equal\fP (const \fB_Base_bitset\fP< _Nw > &__x) const"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static _WordT \fB_S_maskbit\fP (size_t __pos)"
.br
.ti -1c
.RI "static size_t \fB_S_whichbit\fP (size_t __pos)"
.br
.ti -1c
.RI "static size_t \fB_S_whichbyte\fP (size_t __pos)"
.br
.ti -1c
.RI "static size_t \fB_S_whichword\fP (size_t __pos)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "_WordT \fB_M_w\fP [_Nw]"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBhash\fP"
.br
.ti -1c
.RI "class \fBreference\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<size_t _Nb> class std::bitset< _Nb >"
The bitset class represents a \fIfixed-size\fP sequence of bits. 

(Note that bitset does \fInot\fP meet the formal requirements of a \fCcontainer\fP. Mainly, it lacks iterators.)
.PP
The template argument, \fINb\fP, may be any non-negative number, specifying the number of bits (e.g., '0', '12', '1024*1024').
.PP
In the general unoptimized case, storage is allocated in word-sized blocks. Let B be the number of bits in a word, then (Nb+(B-1))/B words will be used for storage. B - NbB bits are unused. (They are the high-order bits in the highest word.) It is a class invariant that those unused bits are always zero.
.PP
If you think of bitset as \fIa simple array of bits\fP, be aware that your mental picture is reversed: a bitset behaves the same way as bits in integers do, with the bit at index 0 in the \fIleast significant / right-hand\fP position, and the bit at index Nb-1 in the \fImost significant / left-hand\fP position. Thus, unlike other containers, a bitset's index \fIcounts from right to left\fP, to put it very loosely.
.PP
This behavior is preserved when translating to and from strings. For example, the first line of the following program probably prints \fIb('a') is 0001100001\fP on a modern ASCII system.
.PP
.PP
.nf
     #include <bitset>
     #include <iostream>
     #include <sstream>

     using namespace std;

     int main()
     {
         long         a = 'a';
         bitset<10>   b(a);

         cout << 'b('a') is ' << b << endl;

         ostringstream s;
         s << b;
         string  str = s.str();
         cout << 'index 3 in the string is ' << str[3] << ' but\n'
              << 'index 3 in the bitset is ' << b[3] << endl;
     }
.fi
.PP
.PP
Also see: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt12ch33s02.html for a description of extensions.
.PP
Most of the actual code isn't contained in bitset<> itself, but in the base class \fB_Base_bitset\fP. The base class works with whole words, not with individual bits. This allows us to specialize \fB_Base_bitset\fP for the important special case where the bitset is only a single word.
.PP
Extra confusion can result due to the fact that the storage for \fB_Base_bitset\fP \fIis\fP a regular array, and is indexed as such. This is carefully encapsulated. 
.PP
Definition at line 709 of file bitset.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<size_t _Nb> \fBstd::bitset\fP< _Nb >::\fBbitset\fP ()\fC [inline]\fP"
.PP
All bits set to zero. 
.PP
Definition at line 803 of file bitset.
.SS "template<size_t _Nb> \fBstd::bitset\fP< _Nb >::\fBbitset\fP (unsigned long long __val)\fC [inline]\fP"
.PP
Initial bits bitwise-copied from a single word (others set to zero). 
.PP
Definition at line 808 of file bitset.
.SS "template<size_t _Nb> template<class _CharT , class _Traits , class _Alloc > \fBstd::bitset\fP< _Nb >::\fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > & __s, size_t __position = \fC0\fP)\fC [inline, explicit]\fP"
.PP
Use a subset of a string. \fBParameters:\fP
.RS 4
\fIs\fP A string of \fI0\fP and \fI1\fP characters. 
.br
\fIposition\fP Index of the first character in \fIs\fP to use; defaults to zero. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of \fIs\fP. 
.br
\fI\fBstd::invalid_argument\fP\fP If a character appears in the string which is neither \fI0\fP nor \fI1\fP. 
.RE
.PP

.PP
Definition at line 826 of file bitset.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::size().
.SS "template<size_t _Nb> template<class _CharT , class _Traits , class _Alloc > \fBstd::bitset\fP< _Nb >::\fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > & __s, size_t __position, size_t __n)\fC [inline]\fP"
.PP
Use a subset of a string. \fBParameters:\fP
.RS 4
\fIs\fP A string of \fI0\fP and \fI1\fP characters. 
.br
\fIposition\fP Index of the first character in \fIs\fP to use. 
.br
\fIn\fP The number of characters to copy. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of \fIs\fP. 
.br
\fI\fBstd::invalid_argument\fP\fP If a character appears in the string which is neither \fI0\fP nor \fI1\fP. 
.RE
.PP

.PP
Definition at line 848 of file bitset.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::size().
.SS "template<size_t _Nb> \fBstd::bitset\fP< _Nb >::\fBbitset\fP (const char * __str)\fC [inline, explicit]\fP"
.PP
Construct from a string. \fBParameters:\fP
.RS 4
\fIstr\fP A string of \fI0\fP and \fI1\fP characters. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::invalid_argument\fP\fP If a character appears in the string which is neither \fI0\fP nor \fI1\fP. 
.RE
.PP

.PP
Definition at line 880 of file bitset.
.SH "Member Function Documentation"
.PP 
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::all () const\fC [inline]\fP"
.PP
Tests whether all the bits are on. \fBReturns:\fP
.RS 4
True if all the bits are set. 
.RE
.PP

.PP
Definition at line 1267 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::any () const\fC [inline]\fP"
.PP
Tests whether any of the bits are on. \fBReturns:\fP
.RS 4
True if at least one bit is set. 
.RE
.PP

.PP
Definition at line 1275 of file bitset.
.SS "template<size_t _Nb> size_t \fBstd::bitset\fP< _Nb >::count () const\fC [inline]\fP"
.PP
Returns the number of bits which are set. 
.PP
Definition at line 1227 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::flip (size_t __position)\fC [inline]\fP"
.PP
Toggles a given bit to its opposite value. \fBParameters:\fP
.RS 4
\fIposition\fP The index of the bit. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of the set. 
.RE
.PP

.PP
Definition at line 1067 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::flip ()\fC [inline]\fP"
.PP
Toggles every bit to its opposite value. 
.PP
Definition at line 1054 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::none () const\fC [inline]\fP"
.PP
Tests whether any of the bits are on. \fBReturns:\fP
.RS 4
True if none of the bits are set. 
.RE
.PP

.PP
Definition at line 1283 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::operator!= (const \fBbitset\fP< _Nb > & __rhs) const\fC [inline]\fP"
.PP
These comparisons for equality/inequality are, well, \fIbitwise\fP. 
.PP
Definition at line 1242 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator&= (const \fBbitset\fP< _Nb > & __rhs)\fC [inline]\fP"
.PP
Operations on bitsets. \fBParameters:\fP
.RS 4
\fIrhs\fP A same-sized bitset.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 901 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> \fBstd::bitset\fP< _Nb >::operator<< (size_t __position) const\fC [inline]\fP"
.PP
Self-explanatory. 
.PP
Definition at line 1289 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator<<= (size_t __position)\fC [inline]\fP"
.PP
Operations on bitsets. \fBParameters:\fP
.RS 4
\fIposition\fP The number of places to shift.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 930 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::operator== (const \fBbitset\fP< _Nb > & __rhs) const\fC [inline]\fP"
.PP
These comparisons for equality/inequality are, well, \fIbitwise\fP. 
.PP
Definition at line 1238 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> \fBstd::bitset\fP< _Nb >::operator>> (size_t __position) const\fC [inline]\fP"
.PP
Self-explanatory. 
.PP
Definition at line 1293 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator>>= (size_t __position)\fC [inline]\fP"
.PP
Operations on bitsets. \fBParameters:\fP
.RS 4
\fIposition\fP The number of places to shift.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 943 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::operator[] (size_t __position) const\fC [inline]\fP"
.PP
Array-indexing support. \fBParameters:\fP
.RS 4
\fIposition\fP Index into the bitset. 
.RE
.PP
\fBReturns:\fP
.RS 4
A bool for a \fIconst bitset\fP. For non-const bitsets, an instance of the reference proxy class. 
.RE
.PP
\fBNote:\fP
.RS 4
These operators do no range checking and throw no exceptions, as required by DR 11 to the standard.
.RE
.PP
_GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already resolves DR 11 (items 1 and 2), but does not do the range-checking required by that DR's resolution. -pme The DR has since been changed: range-checking is a precondition (users' responsibility), and these functions must not throw. -pme 
.PP
Definition at line 1099 of file bitset.
.SS "template<size_t _Nb> \fBreference\fP \fBstd::bitset\fP< _Nb >::operator[] (size_t __position)\fC [inline]\fP"
.PP
Array-indexing support. \fBParameters:\fP
.RS 4
\fIposition\fP Index into the bitset. 
.RE
.PP
\fBReturns:\fP
.RS 4
A bool for a \fIconst bitset\fP. For non-const bitsets, an instance of the reference proxy class. 
.RE
.PP
\fBNote:\fP
.RS 4
These operators do no range checking and throw no exceptions, as required by DR 11 to the standard.
.RE
.PP
_GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already resolves DR 11 (items 1 and 2), but does not do the range-checking required by that DR's resolution. -pme The DR has since been changed: range-checking is a precondition (users' responsibility), and these functions must not throw. -pme 
.PP
Definition at line 1095 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator^= (const \fBbitset\fP< _Nb > & __rhs)\fC [inline]\fP"
.PP
Operations on bitsets. \fBParameters:\fP
.RS 4
\fIrhs\fP A same-sized bitset.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 915 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator|= (const \fBbitset\fP< _Nb > & __rhs)\fC [inline]\fP"
.PP
Operations on bitsets. \fBParameters:\fP
.RS 4
\fIrhs\fP A same-sized bitset.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 908 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> \fBstd::bitset\fP< _Nb >::operator~ () const\fC [inline]\fP"
.PP
See the no-argument \fBflip()\fP. 
.PP
Definition at line 1076 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::reset ()\fC [inline]\fP"
.PP
Sets every bit to false. 
.PP
Definition at line 1029 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::reset (size_t __position)\fC [inline]\fP"
.PP
Sets a given bit to false. \fBParameters:\fP
.RS 4
\fIposition\fP The index of the bit. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of the set.
.RE
.PP
Same as writing \fCset(pos,false)\fP. 
.PP
Definition at line 1043 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::\fBset\fP ()\fC [inline]\fP"
.PP
Sets every bit to true. 
.PP
Definition at line 1004 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::\fBset\fP (size_t __position, bool __val = \fCtrue\fP)\fC [inline]\fP"
.PP
Sets a given bit to a particular value. \fBParameters:\fP
.RS 4
\fIposition\fP The index of the bit. 
.br
\fIval\fP Either true or false, defaults to true. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of the set. 
.RE
.PP

.PP
Definition at line 1018 of file bitset.
.SS "template<size_t _Nb> size_t \fBstd::bitset\fP< _Nb >::size () const\fC [inline]\fP"
.PP
Returns the total number of bits. 
.PP
Definition at line 1232 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::test (size_t __position) const\fC [inline]\fP"
.PP
Tests the value of a bit. \fBParameters:\fP
.RS 4
\fIposition\fP The index of a bit. 
.RE
.PP
\fBReturns:\fP
.RS 4
The value at \fIpos\fP. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of the set. 
.RE
.PP

.PP
Definition at line 1253 of file bitset.
.SS "template<size_t _Nb> template<class _CharT , class _Traits , class _Alloc > \fBstd::basic_string\fP<_CharT, _Traits, _Alloc> \fBstd::bitset\fP< _Nb >::to_string () const\fC [inline]\fP"
.PP
Returns a character interpretation of the bitset. \fBReturns:\fP
.RS 4
The string equivalent of the bits.
.RE
.PP
Note the ordering of the bits: decreasing character positions correspond to increasing bit positions (see the main class notes for an example). 
.PP
Definition at line 1129 of file bitset.
.SS "template<size_t _Nb> unsigned long \fBstd::bitset\fP< _Nb >::to_ulong () const\fC [inline]\fP"
.PP
Returns a numerical interpretation of the bitset. \fBReturns:\fP
.RS 4
The integral equivalent of the bits. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::overflow_error\fP\fP If there are too many bits to be represented in an \fCunsigned\fP \fClong\fP. 
.RE
.PP

.PP
Definition at line 1110 of file bitset.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
