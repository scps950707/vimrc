.TH "std::insert_iterator" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::insert_iterator \- 
.PP
Turns assignment into insertion.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBiterator< output_iterator_tag, void, void, void, void >\fP.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Container \fBcontainer_type\fP"
.br
.ti -1c
.RI "typedef void \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fBoutput_iterator_tag\fP \fBiterator_category\fP"
.br
.ti -1c
.RI "typedef void \fBpointer\fP"
.br
.ti -1c
.RI "typedef void \fBreference\fP"
.br
.ti -1c
.RI "typedef void \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBinsert_iterator\fP (_Container &__x, typename _Container::iterator __i)"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator*\fP ()"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator=\fP (const typename _Container::value_type &__value)"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator=\fP (typename _Container::value_type &&__value)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Container * \fBcontainer\fP"
.br
.ti -1c
.RI "_Container::iterator \fBiter\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Container> class std::insert_iterator< _Container >"
Turns assignment into insertion. 

These are output iterators, constructed from a container-of-T. Assigning a T to the iterator inserts it in the container at the iterator's position, rather than overwriting the value at that position.
.PP
(Sequences will actually insert a \fIcopy\fP of the value before the iterator's position.)
.PP
Tip: Using the inserter function to create these iterators can save typing. 
.PP
Definition at line 579 of file stl_iterator.h.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _Container> typedef _Container \fBstd::insert_iterator\fP< _Container >::\fBcontainer_type\fP"
.PP
A nested typedef for the type of whatever container you used. 
.PP
Definition at line 588 of file stl_iterator.h.
.SS "typedef void  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBdifference_type\fP\fC [inherited]\fP"
.PP
Distance between iterators is represented as this type. 
.PP
Definition at line 121 of file stl_iterator_base_types.h.
.SS "typedef \fBoutput_iterator_tag\fP  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBiterator_category\fP\fC [inherited]\fP"
.PP
One of the \fBtag types\fP. 
.PP
Definition at line 117 of file stl_iterator_base_types.h.
.SS "typedef void  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBpointer\fP\fC [inherited]\fP"
.PP
This type represents a pointer-to-value_type. 
.PP
Definition at line 123 of file stl_iterator_base_types.h.
.SS "typedef void  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBreference\fP\fC [inherited]\fP"
.PP
This type represents a reference-to-value_type. 
.PP
Definition at line 125 of file stl_iterator_base_types.h.
.SS "typedef void  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBvalue_type\fP\fC [inherited]\fP"
.PP
The type 'pointed to' by the iterator. 
.PP
Definition at line 119 of file stl_iterator_base_types.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Container> \fBstd::insert_iterator\fP< _Container >::\fBinsert_iterator\fP (_Container & __x, typename _Container::iterator __i)\fC [inline]\fP"The only way to create this iterator is with a container and an initial position (a normal iterator into the container). 
.PP
Definition at line 594 of file stl_iterator.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Container> \fBinsert_iterator\fP& \fBstd::insert_iterator\fP< _Container >::operator* ()\fC [inline]\fP"
.PP
Simply returns *this. 
.PP
Definition at line 648 of file stl_iterator.h.
.SS "template<typename _Container> \fBinsert_iterator\fP& \fBstd::insert_iterator\fP< _Container >::operator++ (int)\fC [inline]\fP"
.PP
Simply returns *this. (This iterator does not \fImove\fP.). 
.PP
Definition at line 658 of file stl_iterator.h.
.SS "template<typename _Container> \fBinsert_iterator\fP& \fBstd::insert_iterator\fP< _Container >::operator++ ()\fC [inline]\fP"
.PP
Simply returns *this. (This iterator does not \fImove\fP.). 
.PP
Definition at line 653 of file stl_iterator.h.
.SS "template<typename _Container> \fBinsert_iterator\fP& \fBstd::insert_iterator\fP< _Container >::operator= (const typename _Container::value_type & __value)\fC [inline]\fP"\fBParameters:\fP
.RS 4
\fIvalue\fP An instance of whatever type container_type::const_reference is; presumably a reference-to-const T for container<T>. 
.RE
.PP
\fBReturns:\fP
.RS 4
This iterator, for chained operations.
.RE
.PP
This kind of iterator maintains its own position in the container. Assigning a value to the iterator will insert the value into the container at the place before the iterator.
.PP
The position is maintained such that subsequent assignments will insert values immediately after one another. For example, 
.PP
.nf
     // vector v contains A and Z

     insert_iterator i (v, ++v.begin());
     i = 1;
     i = 2;
     i = 3;

     // vector v contains A, 1, 2, 3, and Z

.fi
.PP
 
.PP
Definition at line 630 of file stl_iterator.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
