.TH "std::shared_ptr" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::shared_ptr \- 
.PP
A smart pointer with reference-counted copy semantics.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits __shared_ptr< _Tp >.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBshared_ptr\fP ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (_Tp1 *__p)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Deleter , typename _Alloc > \fBshared_ptr\fP (_Tp1 *__p, _Deleter __d, const _Alloc &__a)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (\fBshared_ptr\fP< _Tp1 > &&__r)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (const \fBweak_ptr\fP< _Tp1 > &__r)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (const \fBshared_ptr\fP< _Tp1 > &__r, _Tp *__p)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (\fBstd::auto_ptr\fP< _Tp1 > &&__r)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Del > \fBshared_ptr\fP (\fBstd::unique_ptr\fP< _Tp1, _Del > &&__r)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Deleter > \fBshared_ptr\fP (_Tp1 *__p, _Deleter __d)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (const \fBshared_ptr\fP< _Tp1 > &__r)"
.br
.ti -1c
.RI "\fBshared_ptr\fP (\fBshared_ptr\fP &&__r)"
.br
.ti -1c
.RI "template<class _Tp1 > \fBshared_ptr\fP & \fBoperator=\fP (\fBshared_ptr\fP< _Tp1 > &&__r)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP & \fBoperator=\fP (const \fBshared_ptr\fP< _Tp1 > &__r)"
.br
.ti -1c
.RI "\fBshared_ptr\fP & \fBoperator=\fP (\fBshared_ptr\fP &&__r)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Del > \fBshared_ptr\fP & \fBoperator=\fP (\fBstd::unique_ptr\fP< _Tp1, _Del > &&__r)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP & \fBoperator=\fP (\fBstd::auto_ptr\fP< _Tp1 > &&__r)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _Tp1 , typename _Alloc , typename... _Args> \fBshared_ptr\fP< _Tp1 > \fBallocate_shared\fP (_Alloc __a, _Args &&...__args)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp> class std::shared_ptr< _Tp >"
A smart pointer with reference-counted copy semantics. 

The object pointed to is deleted when the last \fBshared_ptr\fP pointing to it is destroyed or reset. 
.PP
Definition at line 91 of file shared_ptr.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp> \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP ()\fC [inline]\fP"
.PP
Construct an empty shared_ptr. \fBPostcondition:\fP
.RS 4
use_count()==0 && get()==0 
.RE
.PP

.PP
Definition at line 98 of file shared_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (_Tp1 * __p)\fC [inline, explicit]\fP"
.PP
Construct a shared_ptr that owns the pointer \fI__p\fP. \fBParameters:\fP
.RS 4
\fI__p\fP A pointer that is convertible to element_type*. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 1 && get() == __p 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::bad_alloc\fP,in\fP which case \fCdelete\fP \fI__p\fP is called. 
.RE
.PP

.PP
Definition at line 107 of file shared_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 , typename _Deleter > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (_Tp1 * __p, _Deleter __d)\fC [inline]\fP"
.PP
Construct a shared_ptr that owns the pointer \fI__p\fP and the deleter \fI__d\fP. \fBParameters:\fP
.RS 4
\fI__p\fP A pointer. 
.br
\fI__d\fP A deleter. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 1 && get() == __p 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::bad_alloc\fP,in\fP which case \fI__d(__p)\fP is called.
.RE
.PP
Requirements: _Deleter's copy constructor and destructor must not throw
.PP
__shared_ptr will release __p by calling __d(__p) 
.PP
Definition at line 123 of file shared_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 , typename _Deleter , typename _Alloc > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (_Tp1 * __p, _Deleter __d, const _Alloc & __a)\fC [inline]\fP"
.PP
Construct a shared_ptr that owns the pointer \fI__p\fP and the deleter \fI__d\fP. \fBParameters:\fP
.RS 4
\fI__p\fP A pointer. 
.br
\fI__d\fP A deleter. 
.br
\fI__a\fP An allocator. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 1 && get() == __p 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::bad_alloc\fP,in\fP which case \fI__d(__p)\fP is called.
.RE
.PP
Requirements: _Deleter's copy constructor and destructor must not throw _Alloc's copy constructor and destructor must not throw.
.PP
__shared_ptr will release __p by calling __d(__p) 
.PP
Definition at line 141 of file shared_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (const \fBshared_ptr\fP< _Tp1 > & __r, _Tp * __p)\fC [inline]\fP"
.PP
Constructs a shared_ptr instance that stores \fI__p\fP and shares ownership with \fI__r\fP. \fBParameters:\fP
.RS 4
\fI__r\fP A shared_ptr. 
.br
\fI__p\fP A pointer that will remain valid while \fI*__r\fP is valid. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
get() == __p && use_count() == __r.use_count()
.RE
.PP
This can be used to construct a \fC\fBshared_ptr\fP\fP to a sub-object of an object managed by an existing \fC\fBshared_ptr\fP\fP.
.PP
.PP
.nf
 shared_ptr< pair<int,int> > pii(new pair<int,int>());
 shared_ptr<int> pi(pii, &pii->first);
 assert(pii.use_count() == 2);
.fi
.PP
 
.PP
Definition at line 163 of file shared_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (const \fBshared_ptr\fP< _Tp1 > & __r)\fC [inline]\fP"
.PP
If \fI__r\fP is empty, constructs an empty shared_ptr; otherwise construct a shared_ptr that shares ownership with \fI__r\fP. \fBParameters:\fP
.RS 4
\fI__r\fP A shared_ptr. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
get() == __r.get() && use_count() == __r.use_count() 
.RE
.PP

.PP
Definition at line 174 of file shared_ptr.h.
.SS "template<typename _Tp> \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (\fBshared_ptr\fP< _Tp > && __r)\fC [inline]\fP"
.PP
Move-constructs a shared_ptr instance from \fI__r\fP. \fBParameters:\fP
.RS 4
\fI__r\fP A shared_ptr rvalue. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
*this contains the old value of \fI__r\fP, \fI__r\fP is empty. 
.RE
.PP

.PP
Definition at line 181 of file shared_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (\fBshared_ptr\fP< _Tp1 > && __r)\fC [inline]\fP"
.PP
Move-constructs a shared_ptr instance from \fI__r\fP. \fBParameters:\fP
.RS 4
\fI__r\fP A shared_ptr rvalue. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
*this contains the old value of \fI__r\fP, \fI__r\fP is empty. 
.RE
.PP

.PP
Definition at line 190 of file shared_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (const \fBweak_ptr\fP< _Tp1 > & __r)\fC [inline, explicit]\fP"
.PP
Constructs a shared_ptr that shares ownership with \fI__r\fP and stores a copy of the pointer stored in \fI__r\fP. \fBParameters:\fP
.RS 4
\fI__r\fP A \fBweak_ptr\fP. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == __r.use_count() 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIbad_weak_ptr\fP when __r.expired(), in which case the constructor has no effect. 
.RE
.PP

.PP
Definition at line 202 of file shared_ptr.h.
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<typename _Tp> template<typename _Tp1 , typename _Alloc , typename... _Args> \fBshared_ptr\fP<_Tp1> allocate_shared (_Alloc __a, _Args &&... __args)\fC [friend]\fP"
.PP
Create an object that is owned by a \fBshared_ptr\fP. \fBParameters:\fP
.RS 4
\fI__a\fP An allocator. 
.br
\fI__args\fP Arguments for the \fI_Tp\fP object's constructor. 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fBshared_ptr\fP that owns the newly created object. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIAn\fP exception thrown from \fI_Alloc::allocate\fP or from the constructor of \fI_Tp\fP.
.RE
.PP
A copy of \fI__a\fP will be used to allocate memory for the \fBshared_ptr\fP and the new object. 
.PP
Definition at line 452 of file shared_ptr.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
