.TH "__gnu_profile" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_profile \- 
.PP
GNU profile code for public use.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fB__container_size_info\fP"
.br
.RI "\fIA container size instrumentation line in the object table. \fP"
.ti -1c
.RI "class \fB__container_size_stack_info\fP"
.br
.RI "\fIA container size instrumentation line in the stack table. \fP"
.ti -1c
.RI "class \fB__hashfunc_info\fP"
.br
.RI "\fIA hash performance instrumentation line in the object table. \fP"
.ti -1c
.RI "class \fB__hashfunc_stack_info\fP"
.br
.RI "\fIA hash performance instrumentation line in the stack table. \fP"
.ti -1c
.RI "class \fB__list2vector_info\fP"
.br
.RI "\fIA list-to-vector instrumentation line in the object table. \fP"
.ti -1c
.RI "class \fB__map2umap_info\fP"
.br
.RI "\fIA map-to-unordered_map instrumentation line in the object table. \fP"
.ti -1c
.RI "class \fB__map2umap_stack_info\fP"
.br
.RI "\fIA map-to-unordered_map instrumentation line in the stack table. \fP"
.ti -1c
.RI "class \fB__object_info_base\fP"
.br
.RI "\fIBase class for a line in the object table. \fP"
.ti -1c
.RI "struct \fB__reentrance_guard\fP"
.br
.RI "\fIReentrance guard. \fP"
.ti -1c
.RI "class \fB__stack_hash\fP"
.br
.RI "\fIHash function for summary trace using call stack as index. \fP"
.ti -1c
.RI "class \fB__stack_info_base\fP"
.br
.RI "\fIBase class for a line in the stack table. \fP"
.ti -1c
.RI "class \fB__trace_base\fP"
.br
.RI "\fIBase class for all trace producers. \fP"
.ti -1c
.RI "class \fB__trace_container_size\fP"
.br
.RI "\fIContainer size instrumentation trace producer. \fP"
.ti -1c
.RI "class \fB__trace_hash_func\fP"
.br
.RI "\fIHash performance instrumentation producer. \fP"
.ti -1c
.RI "class \fB__trace_hashtable_size\fP"
.br
.RI "\fIHashtable size instrumentation trace producer. \fP"
.ti -1c
.RI "class \fB__trace_map2umap\fP"
.br
.RI "\fIMap-to-unordered_map instrumentation producer. \fP"
.ti -1c
.RI "class \fB__trace_vector_size\fP"
.br
.RI "\fIHashtable size instrumentation trace producer. \fP"
.ti -1c
.RI "class \fB__trace_vector_to_list\fP"
.br
.RI "\fIVector-to-list instrumentation producer. \fP"
.ti -1c
.RI "class \fB__vector2list_info\fP"
.br
.RI "\fIA vector-to-list instrumentation line in the object table. \fP"
.ti -1c
.RI "class \fB__vector2list_stack_info\fP"
.br
.RI "\fIA vector-to-list instrumentation line in the stack table. \fP"
.ti -1c
.RI "struct \fB__warning_data\fP"
.br
.RI "\fIRepresentation of a warning. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef std::std::vector< __cost_factor * > \fB__cost_factor_vector\fP"
.br
.ti -1c
.RI "typedef std::std::unordered_map< \fBstd::string\fP, \fBstd::string\fP > \fB__env_t\fP"
.br
.ti -1c
.RI "typedef void * \fB__instruction_address_t\fP"
.br
.ti -1c
.RI "typedef const void * \fB__object_t\fP"
.br
.ti -1c
.RI "typedef std::std::vector< __instruction_address_t > \fB__stack_npt\fP"
.br
.ti -1c
.RI "typedef __stack_npt * \fB__stack_t\fP"
.br
.ti -1c
.RI "typedef std::std::vector< \fB__warning_data\fP > \fB__warning_vector_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB__state_type\fP { \fB__ON\fP, \fB__OFF\fP, \fB__INVALID\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "size_t \fB__env_to_size_t\fP (const char *__env_var, size_t __default_value)"
.br
.ti -1c
.RI "__cost_factor_vector *& \fB__get___cost_factors\fP ()"
.br
.ti -1c
.RI "\fB__env_t\fP & \fB__get___env\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB__get___global_lock\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___list_iterate_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___list_resize_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___list_shift_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___map_erase_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___map_find_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___map_insert_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___map_iterate_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___umap_erase_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___umap_find_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___umap_insert_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___umap_iterate_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___vector_iterate_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___vector_resize_cost_factor\fP ()"
.br
.ti -1c
.RI "__cost_factor & \fB__get___vector_shift_cost_factor\fP ()"
.br
.ti -1c
.RI "\fB__trace_hash_func\fP *& \fB__get__S_hash_func\fP ()"
.br
.ti -1c
.RI "\fB__trace_hashtable_size\fP *& \fB__get__S_hashtable_size\fP ()"
.br
.ti -1c
.RI "__trace_list_to_slist *& \fB__get__S_list_to_slist\fP ()"
.br
.ti -1c
.RI "__trace_list_to_vector *& \fB__get__S_list_to_vector\fP ()"
.br
.ti -1c
.RI "\fB__trace_map2umap\fP *& \fB__get__S_map2umap\fP ()"
.br
.ti -1c
.RI "size_t & \fB__get__S_max_mem\fP ()"
.br
.ti -1c
.RI "size_t & \fB__get__S_max_stack_depth\fP ()"
.br
.ti -1c
.RI "size_t & \fB__get__S_max_warn_count\fP ()"
.br
.ti -1c
.RI "const char *& \fB__get__S_trace_file_name\fP ()"
.br
.ti -1c
.RI "\fB__trace_vector_size\fP *& \fB__get__S_vector_size\fP ()"
.br
.ti -1c
.RI "\fB__trace_vector_to_list\fP *& \fB__get__S_vector_to_list\fP ()"
.br
.ti -1c
.RI "__stack_t \fB__get_stack\fP ()"
.br
.ti -1c
.RI "bool \fB__is_invalid\fP ()"
.br
.ti -1c
.RI "bool \fB__is_off\fP ()"
.br
.ti -1c
.RI "bool \fB__is_on\fP ()"
.br
.ti -1c
.RI "int \fB__log2\fP (size_t __size)"
.br
.ti -1c
.RI "int \fB__log_magnitude\fP (float __f)"
.br
.ti -1c
.RI "float \fB__map_erase_cost\fP (size_t __size)"
.br
.ti -1c
.RI "float \fB__map_find_cost\fP (size_t __size)"
.br
.ti -1c
.RI "float \fB__map_insert_cost\fP (size_t __size)"
.br
.ti -1c
.RI "size_t \fB__max_mem\fP ()"
.br
.ti -1c
.RI "FILE * \fB__open_output_file\fP (const char *__extension)"
.br
.ti -1c
.RI "bool \fB__profcxx_init\fP (void)"
.br
.ti -1c
.RI "void \fB__profcxx_init_unconditional\fP ()"
.br
.ti -1c
.RI "void \fB__read_cost_factors\fP ()"
.br
.ti -1c
.RI "void \fB__report\fP (void)"
.br
.ti -1c
.RI "void \fB__set_cost_factors\fP ()"
.br
.ti -1c
.RI "void \fB__set_max_mem\fP ()"
.br
.ti -1c
.RI "void \fB__set_max_stack_trace_depth\fP ()"
.br
.ti -1c
.RI "void \fB__set_max_warn_count\fP ()"
.br
.ti -1c
.RI "void \fB__set_trace_path\fP ()"
.br
.ti -1c
.RI "\fB__size\fP (const __stack_t &__stack)"
.br
.ti -1c
.RI "size_t \fB__stack_max_depth\fP ()"
.br
.ti -1c
.RI "void \fB__trace_hash_func_construct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_hash_func_destruct\fP (const void *, size_t, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_hash_func_init\fP ()"
.br
.ti -1c
.RI "void \fB__trace_hash_func_report\fP (FILE *__f, __warning_vector_t &__warnings)"
.br
.ti -1c
.RI "void \fB__trace_hashtable_size_construct\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_hashtable_size_destruct\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_hashtable_size_init\fP ()"
.br
.ti -1c
.RI "void \fB__trace_hashtable_size_report\fP (FILE *__f, __warning_vector_t &__warnings)"
.br
.ti -1c
.RI "void \fB__trace_hashtable_size_resize\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_list_to_set_construct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_set_destruct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_set_find\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_list_to_set_insert\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_list_to_set_invalid_operator\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_set_iterate\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_list_to_slist_construct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_slist_destruct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_slist_init\fP ()"
.br
.ti -1c
.RI "void \fB__trace_list_to_slist_operation\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_slist_report\fP (FILE *__f, __warning_vector_t &__warnings)"
.br
.ti -1c
.RI "void \fB__trace_list_to_slist_rewind\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_vector_construct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_vector_destruct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_vector_init\fP ()"
.br
.ti -1c
.RI "void \fB__trace_list_to_vector_insert\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_list_to_vector_invalid_operator\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_list_to_vector_iterate\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_list_to_vector_report\fP (FILE *__f, __warning_vector_t &__warnings)"
.br
.ti -1c
.RI "void \fB__trace_list_to_vector_resize\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_construct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_destruct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_erase\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_find\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_init\fP ()"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_insert\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_invalidate\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_iterate\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_map_to_unordered_map_report\fP (FILE *__f, __warning_vector_t &__warnings)"
.br
.ti -1c
.RI "void \fB__trace_vector_size_construct\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_vector_size_destruct\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_vector_size_init\fP ()"
.br
.ti -1c
.RI "void \fB__trace_vector_size_report\fP (FILE *, __warning_vector_t &)"
.br
.ti -1c
.RI "void \fB__trace_vector_size_resize\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_construct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_destruct\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_find\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_init\fP ()"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_insert\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_invalid_operator\fP (const void *)"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_iterate\fP (const void *, size_t)"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_report\fP (FILE *, __warning_vector_t &)"
.br
.ti -1c
.RI "void \fB__trace_vector_to_list_resize\fP (const void *, size_t, size_t)"
.br
.ti -1c
.RI "bool \fB__turn\fP (__state_type __s)"
.br
.ti -1c
.RI "bool \fB__turn_off\fP ()"
.br
.ti -1c
.RI "bool \fB__turn_on\fP ()"
.br
.ti -1c
.RI "void \fB__write\fP (FILE *__f, const __stack_t __stack)"
.br
.ti -1c
.RI "void \fB__write_cost_factors\fP ()"
.br
.ti -1c
.RI "\fB_GLIBCXX_PROFILE_DEFINE_DATA\fP (__state_type, __state, __INVALID)"
.br
.in -1c
.SH "Detailed Description"
.PP 
GNU profile code for public use. 
.SH "Typedef Documentation"
.PP 
.SS "typedef std:: std ::\fBunordered_map\fP<\fBstd::string\fP, \fBstd::string\fP> \fB__gnu_profile::__env_t\fP"
.PP
Internal environment. Values can be set one of two ways: 1. In config file 'var = value'. The default config file path is libstdcxx-profile.conf. 2. By setting process environment variables. For instance, in a Bash shell you can set the unit cost of iterating through a map like this: export __map_iterate_cost_factor=5.0. If a value is set both in the input file and through an environment variable, the environment value takes precedence. 
.PP
Definition at line 75 of file profiler_trace.h.
.SH "Function Documentation"
.PP 
.SS "__gnu_cxx::__mutex& __gnu_profile::__get___global_lock ()\fC [inline]\fP"
.PP
Master lock. 
.PP
Definition at line 79 of file profiler_trace.h.
.SS "bool __gnu_profile::__profcxx_init (void)\fC [inline]\fP"
.PP
This function must be called by each instrumentation point. The common path is inlined fully. 
.PP
Definition at line 617 of file profiler_trace.h.
.SS "void __gnu_profile::__report (void)\fC [inline]\fP"
.PP
Final report method, registered with \fBatexit\fP. This can also be called directly by user code, including signal handlers. It is protected against deadlocks by the reentrance guard in \fBprofiler.h\fP. However, when called from a signal handler that triggers while within \fB__gnu_profile\fP (under the guarded zone), no output will be produced. 
.PP
Definition at line 398 of file profiler_trace.h.
.PP
References std::min().
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
