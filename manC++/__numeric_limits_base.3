.TH "std::__numeric_limits_base" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__numeric_limits_base \- 
.PP
Part of \fBstd::numeric_limits\fP.  

.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBstd::numeric_limits< _Tp >\fP.
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBdigits\fP"
.br
.ti -1c
.RI "static const int \fBdigits10\fP"
.br
.ti -1c
.RI "static const \fBfloat_denorm_style\fP \fBhas_denorm\fP"
.br
.ti -1c
.RI "static const bool \fBhas_denorm_loss\fP"
.br
.ti -1c
.RI "static const bool \fBhas_infinity\fP"
.br
.ti -1c
.RI "static const bool \fBhas_quiet_NaN\fP"
.br
.ti -1c
.RI "static const bool \fBhas_signaling_NaN\fP"
.br
.ti -1c
.RI "static const bool \fBis_bounded\fP"
.br
.ti -1c
.RI "static const bool \fBis_exact\fP"
.br
.ti -1c
.RI "static const bool \fBis_iec559\fP"
.br
.ti -1c
.RI "static const bool \fBis_integer\fP"
.br
.ti -1c
.RI "static const bool \fBis_modulo\fP"
.br
.ti -1c
.RI "static const bool \fBis_signed\fP"
.br
.ti -1c
.RI "static const bool \fBis_specialized\fP"
.br
.ti -1c
.RI "static const int \fBmax_digits10\fP"
.br
.ti -1c
.RI "static const int \fBmax_exponent\fP"
.br
.ti -1c
.RI "static const int \fBmax_exponent10\fP"
.br
.ti -1c
.RI "static const int \fBmin_exponent\fP"
.br
.ti -1c
.RI "static const int \fBmin_exponent10\fP"
.br
.ti -1c
.RI "static const int \fBradix\fP"
.br
.ti -1c
.RI "static const \fBfloat_round_style\fP \fBround_style\fP"
.br
.ti -1c
.RI "static const bool \fBtinyness_before\fP"
.br
.ti -1c
.RI "static const bool \fBtraps\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Part of \fBstd::numeric_limits\fP. 

The \fCstatic\fP \fCconst\fP members are usable as integral constant expressions.
.PP
\fBNote:\fP
.RS 4
This is a separate class for purposes of efficiency; you should only access these members as part of an instantiation of the \fBstd::numeric_limits\fP class. 
.RE
.PP

.PP
Definition at line 190 of file limits.
.SH "Member Data Documentation"
.PP 
.SS "const int \fBstd::__numeric_limits_base::digits\fP\fC [static]\fP"The number of \fCradix\fP digits that be represented without change: for integer types, the number of non-sign bits in the mantissa; for floating types, the number of \fCradix\fP digits in the mantissa. 
.PP
Definition at line 199 of file limits.
.SS "const int \fBstd::__numeric_limits_base::digits10\fP\fC [static]\fP"The number of base 10 digits that can be represented without change. 
.PP
Definition at line 201 of file limits.
.SS "const \fBfloat_denorm_style\fP \fBstd::__numeric_limits_base::has_denorm\fP\fC [static]\fP"See \fBstd::float_denorm_style\fP for more information. 
.PP
Definition at line 244 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::has_denorm_loss\fP\fC [static]\fP"\fITrue if loss of accuracy is detected as a denormalization loss, rather than as an inexact result.\fP [18.2.1.2]/42 
.PP
Definition at line 247 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::has_infinity\fP\fC [static]\fP"True if the type has a representation for positive infinity. 
.PP
Definition at line 236 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::has_quiet_NaN\fP\fC [static]\fP"True if the type has a representation for a quiet (non-signaling) \fINot a Number\fP. 
.PP
Definition at line 239 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::has_signaling_NaN\fP\fC [static]\fP"True if the type has a representation for a signaling \fINot a Number\fP. 
.PP
Definition at line 242 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_bounded\fP\fC [static]\fP"\fITrue if the set of values representable by the type is finite. All built-in types are bounded, this member would be false for arbitrary precision types.\fP [18.2.1.2]/54 
.PP
Definition at line 255 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_exact\fP\fC [static]\fP"True if the type uses an exact representation. \fIAll integer types are exact, but not all exact types are integer. For example, rational and fixed-exponent representations are exact but not integer.\fP [18.2.1.2]/15 
.PP
Definition at line 216 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_iec559\fP\fC [static]\fP"True if-and-only-if the type adheres to the IEC 559 standard, also known as IEEE 754. (Only makes sense for floating point types.) 
.PP
Definition at line 251 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_integer\fP\fC [static]\fP"True if the type is integer. Is this supposed to be \fIif the type is integral?\fP 
.PP
Definition at line 211 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_modulo\fP\fC [static]\fP"True if the type is \fImodulo\fP, that is, if it is possible to add two positive numbers and have a result that wraps around to a third number that is less. Typically false for floating types, true for unsigned integers, and true for signed integers. 
.PP
Definition at line 260 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_signed\fP\fC [static]\fP"True if the type is signed. 
.PP
Definition at line 208 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_specialized\fP\fC [static]\fP"This will be true for all fundamental types (which have specializations), and false for everything else. 
.PP
Definition at line 194 of file limits.
.SS "const int \fBstd::__numeric_limits_base::max_digits10\fP\fC [static]\fP"The number of base 10 digits required to ensure that values which differ are always differentiated. 
.PP
Definition at line 205 of file limits.
.SS "const int \fBstd::__numeric_limits_base::max_exponent\fP\fC [static]\fP"The maximum positive integer such that \fCradix\fP raised to the power of (one less than that integer) is a representable finite floating point number. 
.PP
Definition at line 230 of file limits.
.SS "const int \fBstd::__numeric_limits_base::max_exponent10\fP\fC [static]\fP"The maximum positive integer such that 10 raised to that power is in the range of representable finite floating point numbers. 
.PP
Definition at line 233 of file limits.
.SS "const int \fBstd::__numeric_limits_base::min_exponent\fP\fC [static]\fP"The minimum negative integer such that \fCradix\fP raised to the power of (one less than that integer) is a normalized floating point number. 
.PP
Definition at line 223 of file limits.
.SS "const int \fBstd::__numeric_limits_base::min_exponent10\fP\fC [static]\fP"The minimum negative integer such that 10 raised to that power is in the range of normalized floating point numbers. 
.PP
Definition at line 226 of file limits.
.SS "const int \fBstd::__numeric_limits_base::radix\fP\fC [static]\fP"For integer types, specifies the base of the representation. For floating types, specifies the base of the exponent representation. 
.PP
Definition at line 219 of file limits.
.SS "const \fBfloat_round_style\fP \fBstd::__numeric_limits_base::round_style\fP\fC [static]\fP"See \fBstd::float_round_style\fP for more information. This is only meaningful for floating types; integer types will all be round_toward_zero. 
.PP
Definition at line 269 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::tinyness_before\fP\fC [static]\fP"True if tininess is detected before rounding. (see IEC 559) 
.PP
Definition at line 265 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::traps\fP\fC [static]\fP"True if trapping is implemented for this type. 
.PP
Definition at line 263 of file limits.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
