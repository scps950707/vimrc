.TH "__gnu_cxx::stdio_filebuf" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_cxx::stdio_filebuf \- 
.PP
Provides a layer of compatibility for C/POSIX.
.PP
This GNU extension provides extensions for working with standard C FILE*'s and POSIX file descriptors. It must be instantiated by the user with the type of character used in the file stream, e.g., stdio_filebuf<char>.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef codecvt< \fBchar_type\fP, char, __state_type > \fB__codecvt_type\fP"
.br
.ti -1c
.RI "typedef __basic_file< char > \fB__file_type\fP"
.br
.ti -1c
.RI "typedef basic_filebuf< \fBchar_type\fP, \fBtraits_type\fP > \fB__filebuf_type\fP"
.br
.ti -1c
.RI "typedef traits_type::state_type \fB__state_type\fP"
.br
.ti -1c
.RI "typedef basic_streambuf< \fBchar_type\fP, \fBtraits_type\fP > \fB__streambuf_type\fP"
.br
.ti -1c
.RI "typedef _CharT \fBchar_type\fP"
.br
.ti -1c
.RI "typedef traits_type::int_type \fBint_type\fP"
.br
.ti -1c
.RI "typedef traits_type::off_type \fBoff_type\fP"
.br
.ti -1c
.RI "typedef traits_type::pos_type \fBpos_type\fP"
.br
.ti -1c
.RI "typedef std::size_t \fBsize_t\fP"
.br
.ti -1c
.RI "typedef _Traits \fBtraits_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstdio_filebuf\fP ()"
.br
.ti -1c
.RI "\fBstdio_filebuf\fP (int __fd, \fBstd::ios_base::openmode\fP __mode, size_t __size=static_cast< size_t >(BUFSIZ))"
.br
.ti -1c
.RI "\fBstdio_filebuf\fP (std::__c_file *__f, \fBstd::ios_base::openmode\fP __mode, size_t __size=static_cast< size_t >(BUFSIZ))"
.br
.ti -1c
.RI "virtual \fB~stdio_filebuf\fP ()"
.br
.ti -1c
.RI "\fB__filebuf_type\fP * \fBclose\fP ()"
.br
.ti -1c
.RI "int \fBfd\fP ()"
.br
.ti -1c
.RI "std::__c_file * \fBfile\fP ()"
.br
.ti -1c
.RI "streamsize \fBin_avail\fP ()"
.br
.ti -1c
.RI "bool \fBis_open\fP () const   throw ()"
.br
.ti -1c
.RI "\fB__filebuf_type\fP * \fBopen\fP (const char *__s, ios_base::openmode __mode)"
.br
.ti -1c
.RI "\fB__filebuf_type\fP * \fBopen\fP (const \fBstd::string\fP &__s, ios_base::openmode __mode)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsbumpc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsgetc\fP ()"
.br
.ti -1c
.RI "streamsize \fBsgetn\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsnextc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputbackc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "streamsize \fBsputn\fP (const \fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "void \fBstossc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsungetc\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_allocate_internal_buffer\fP ()"
.br
.ti -1c
.RI "bool \fB_M_convert_to_external\fP (\fBchar_type\fP *, streamsize)"
.br
.ti -1c
.RI "void \fB_M_create_pback\fP ()"
.br
.ti -1c
.RI "void \fB_M_destroy_internal_buffer\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_destroy_pback\fP ()  throw ()"
.br
.ti -1c
.RI "\fBpos_type\fP \fB_M_seek\fP (\fBoff_type\fP __off, ios_base::seekdir __way, __state_type __state)"
.br
.ti -1c
.RI "void \fB_M_set_buffer\fP (streamsize __off)"
.br
.ti -1c
.RI "bool \fB_M_terminate_output\fP ()"
.br
.ti -1c
.RI "void \fBgbump\fP (int __n)"
.br
.ti -1c
.RI "virtual void \fBimbue\fP (const locale &__loc)"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBoverflow\fP (\fBint_type\fP __c=_Traits::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBoverflow\fP (\fBint_type\fP=traits_type::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBpbackfail\fP (\fBint_type\fP=traits_type::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBpbackfail\fP (\fBint_type\fP __c=_Traits::eof())"
.br
.ti -1c
.RI "void \fBpbump\fP (int __n)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekoff\fP (\fBoff_type\fP __off, ios_base::seekdir __way, ios_base::openmode __mode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekoff\fP (\fBoff_type\fP, ios_base::seekdir, ios_base::openmode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekpos\fP (\fBpos_type\fP __pos, ios_base::openmode __mode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekpos\fP (\fBpos_type\fP, ios_base::openmode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "virtual \fB__streambuf_type\fP * \fBsetbuf\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "virtual basic_streambuf< \fBchar_type\fP, _Traits > * \fBsetbuf\fP (\fBchar_type\fP *, streamsize)"
.br
.ti -1c
.RI "void \fBsetg\fP (\fBchar_type\fP *__gbeg, \fBchar_type\fP *__gnext, \fBchar_type\fP *__gend)"
.br
.ti -1c
.RI "void \fBsetp\fP (\fBchar_type\fP *__pbeg, \fBchar_type\fP *__pend)"
.br
.ti -1c
.RI "virtual streamsize \fBshowmanyc\fP ()"
.br
.ti -1c
.RI "virtual int \fBsync\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBuflow\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBunderflow\fP ()"
.br
.ti -1c
.RI "virtual streamsize \fBxsgetn\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "virtual streamsize \fBxsgetn\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "virtual streamsize \fBxsputn\fP (const \fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "virtual streamsize \fBxsputn\fP (const \fBchar_type\fP *__s, streamsize __n)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBeback\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBgptr\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBegptr\fP () const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBpbase\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBpptr\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBepptr\fP () const "
.br
.in -1c
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fB_M_buf\fP"
.br
.ti -1c
.RI "bool \fB_M_buf_allocated\fP"
.br
.ti -1c
.RI "size_t \fB_M_buf_size\fP"
.br
.ti -1c
.RI "const \fB__codecvt_type\fP * \fB_M_codecvt\fP"
.br
.ti -1c
.RI "char * \fB_M_ext_buf\fP"
.br
.ti -1c
.RI "streamsize \fB_M_ext_buf_size\fP"
.br
.ti -1c
.RI "char * \fB_M_ext_end\fP"
.br
.ti -1c
.RI "const char * \fB_M_ext_next\fP"
.br
.ti -1c
.RI "__file_type \fB_M_file\fP"
.br
.ti -1c
.RI "__c_lock \fB_M_lock\fP"
.br
.ti -1c
.RI "ios_base::openmode \fB_M_mode\fP"
.br
.ti -1c
.RI "bool \fB_M_reading\fP"
.br
.ti -1c
.RI "__state_type \fB_M_state_beg\fP"
.br
.ti -1c
.RI "__state_type \fB_M_state_cur\fP"
.br
.ti -1c
.RI "__state_type \fB_M_state_last\fP"
.br
.ti -1c
.RI "bool \fB_M_writing\fP"
.br
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP \fB_M_pback\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_pback_cur_save\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_pback_end_save\fP"
.br
.ti -1c
.RI "bool \fB_M_pback_init\fP"
.br
.in -1c
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<bool _IsMove, typename _CharT2 > __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, _CharT2 * >::__type \fB__copy_move_a2\fP (istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, _CharT2 *)"
.br
.ti -1c
.RI "streamsize \fB__copy_streambufs_eof\fP (\fB__streambuf_type\fP *, \fB__streambuf_type\fP *, bool &)"
.br
.ti -1c
.RI "class \fBbasic_ios< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_istream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_ostream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "template<typename _CharT2 > __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, istreambuf_iterator< _CharT2 > >::__type \fBfind\fP (istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, const _CharT2 &)"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 , typename _Alloc > basic_istream< _CharT2, _Traits2 > & \fBgetline\fP (basic_istream< _CharT2, _Traits2 > &, basic_string< _CharT2, _Traits2, _Alloc > &, _CharT2)"
.br
.ti -1c
.RI "class \fBios_base\fP"
.br
.ti -1c
.RI "class \fBistreambuf_iterator< char_type, traits_type >\fP"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 > basic_istream< _CharT2, _Traits2 > & \fBoperator>>\fP (basic_istream< _CharT2, _Traits2 > &, _CharT2 *)"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 , typename _Alloc > basic_istream< _CharT2, _Traits2 > & \fBoperator>>\fP (basic_istream< _CharT2, _Traits2 > &, basic_string< _CharT2, _Traits2, _Alloc > &)"
.br
.ti -1c
.RI "class \fBostreambuf_iterator< char_type, traits_type >\fP"
.br
.in -1c 
.in +1c
.ti -1c
.RI "locale \fBpubimbue\fP (const locale &__loc)"
.br
.ti -1c
.RI "locale \fBgetloc\fP () const "
.br
.ti -1c
.RI "\fB__streambuf_type\fP * \fBpubsetbuf\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekoff\fP (\fBoff_type\fP __off, ios_base::seekdir __way, ios_base::openmode __mode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekpos\fP (\fBpos_type\fP __sp, ios_base::openmode __mode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "int \fBpubsync\fP ()"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_end\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_end\fP"
.br
.ti -1c
.RI "locale \fB_M_buf_locale\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT, typename _Traits = std::char_traits<_CharT>> class __gnu_cxx::stdio_filebuf< _CharT, _Traits >"
Provides a layer of compatibility for C/POSIX.
.PP
This GNU extension provides extensions for working with standard C FILE*'s and POSIX file descriptors. It must be instantiated by the user with the type of character used in the file stream, e.g., stdio_filebuf<char>. 
.PP
Definition at line 49 of file stdio_filebuf.h.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> typedef basic_streambuf<\fBchar_type\fP, \fBtraits_type\fP> \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB__streambuf_type\fP\fC [inherited]\fP"
.PP
This is a non-standard type. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 77 of file fstream.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef _CharT \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBchar_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 53 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef traits_type::int_type \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBint_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 55 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef traits_type::off_type \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBoff_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 57 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef traits_type::pos_type \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBpos_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 56 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef _Traits \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBtraits_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 54 of file stdio_filebuf.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBstdio_filebuf\fP ()\fC [inline]\fP"deferred initialization 
.PP
Definition at line 64 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits > \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBstdio_filebuf\fP (int __fd, \fBstd::ios_base::openmode\fP __mode, size_t __size = \fCstatic_cast<size_t>(BUFSIZ)\fP)"\fBParameters:\fP
.RS 4
\fIfd\fP An open file descriptor. 
.br
\fImode\fP Same meaning as in a standard filebuf. 
.br
\fIsize\fP Optimal or preferred size of internal buffer, in chars.
.RE
.PP
This constructor associates a file stream buffer with an open POSIX file descriptor. The file descriptor will be automatically closed when the \fBstdio_filebuf\fP is closed/destroyed. 
.PP
Definition at line 126 of file stdio_filebuf.h.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_buf_size, std::basic_filebuf< _CharT, _Traits >::_M_mode, std::basic_filebuf< _CharT, _Traits >::_M_reading, std::basic_filebuf< _CharT, _Traits >::_M_set_buffer(), and std::basic_filebuf< _CharT, _Traits >::is_open().
.SS "template<typename _CharT , typename _Traits > \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBstdio_filebuf\fP (std::__c_file * __f, \fBstd::ios_base::openmode\fP __mode, size_t __size = \fCstatic_cast<size_t>(BUFSIZ)\fP)"\fBParameters:\fP
.RS 4
\fIf\fP An open \fCFILE*\fP. 
.br
\fImode\fP Same meaning as in a standard filebuf. 
.br
\fIsize\fP Optimal or preferred size of internal buffer, in chars. Defaults to system's \fCBUFSIZ\fP.
.RE
.PP
This constructor associates a file stream buffer with an open C \fCFILE*\fP. The \fCFILE*\fP will not be automatically closed when the \fBstdio_filebuf\fP is closed/destroyed. 
.PP
Definition at line 142 of file stdio_filebuf.h.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_buf_size, std::basic_filebuf< _CharT, _Traits >::_M_mode, std::basic_filebuf< _CharT, _Traits >::_M_reading, std::basic_filebuf< _CharT, _Traits >::_M_set_buffer(), and std::basic_filebuf< _CharT, _Traits >::is_open().
.SS "template<typename _CharT , typename _Traits > \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::~\fBstdio_filebuf\fP ()\fC [virtual]\fP"Closes the external data stream if the file descriptor constructor was used. 
.PP
Definition at line 121 of file stdio_filebuf.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_filebuf\fP< _CharT, _Traits >::_M_create_pback ()\fC [inline, protected, inherited]\fP"Initializes pback buffers, and moves normal buffers to safety. Assumptions: _M_in_cur has already been moved back 
.PP
Definition at line 172 of file fstream.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_filebuf\fP< _CharT, _Traits >::_M_destroy_pback ()  throw ()\fC [inline, protected, inherited]\fP"Deactivates pback buffer contents, and restores normal buffer. Assumptions: The pback buffer has only moved forward. 
.PP
Definition at line 189 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_filebuf\fP< _CharT, _Traits >::_M_set_buffer (\fBstreamsize\fP __off)\fC [inline, protected, inherited]\fP"This function sets the pointers of the internal buffer, both get and put areas. Typically:
.PP
__off == \fBegptr()\fP - \fBeback()\fP upon underflow/uflow (\fBread\fP mode); __off == 0 upon overflow (\fBwrite\fP mode); __off == -1 upon open, setbuf, seekoff/pos (\fBuncommitted\fP mode).
.PP
NB: \fBepptr()\fP - \fBpbase()\fP == _M_buf_size - 1, since _M_buf_size reflects the actual allocated memory and the last cell is reserved for the overflow char of a full put area. 
.PP
Definition at line 387 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_filebuf< _CharT, _Traits >::open(), __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT , typename _Traits > basic_filebuf< _CharT, _Traits >::\fB__filebuf_type\fP * \fBstd::basic_filebuf\fP< _CharT, _Traits >::close ()\fC [inherited]\fP"
.PP
Closes the currently associated file. \fBReturns:\fP
.RS 4
\fCthis\fP on success, NULL on failure
.RE
.PP
If no file is currently open, this function immediately fails.
.PP
If a \fIput buffer area\fP exists, \fCoverflow(eof)\fP is called to flush all the characters. The file is then closed.
.PP
If any operations fail, this function also fails. 
.PP
Definition at line 128 of file fstream.tcc.
.PP
References std::basic_filebuf< _CharT, _Traits >::is_open().
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::open().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::eback () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 460 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::egptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 466 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::showmanyc(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::epptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 513 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> int \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::fd ()\fC [inline]\fP"\fBReturns:\fP
.RS 4
The underlying file descriptor.
.RE
.PP
Once associated with an external data stream, this function can be used to access the underlying POSIX file descriptor. Note that there is no way for the library to track what you do with the descriptor, so be careful. 
.PP
Definition at line 107 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> std::__c_file* \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::file ()\fC [inline]\fP"\fBReturns:\fP
.RS 4
The underlying FILE*.
.RE
.PP
This function can be used to access the underlying 'C' file pointer. Note that there is no way for the library to track what you do with the file, so be careful. 
.PP
Definition at line 117 of file stdio_filebuf.h.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::gbump (int __n)\fC [inline, protected, inherited]\fP"
.PP
Moving the read position. \fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the read position without returning any data. 
.PP
Definition at line 476 of file streambuf.
.SS "template<typename _CharT, typename _Traits> locale \fBstd::basic_streambuf\fP< _CharT, _Traits >::getloc () const\fC [inline, inherited]\fP"
.PP
Locale access. \fBReturns:\fP
.RS 4
The current locale in effect.
.RE
.PP
If pubimbue(loc) has been called, then the most recent \fCloc\fP is returned. Otherwise the global locale in effect at the time of construction is returned. 
.PP
Definition at line 222 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::gptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 463 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_filebuf< _CharT, _Traits >::showmanyc(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT , typename _Traits > void \fBstd::basic_filebuf\fP< _CharT, _Traits >::imbue (const \fBlocale\fP &)\fC [protected, virtual, inherited]\fP"
.PP
Changes translations. \fBParameters:\fP
.RS 4
\fIloc\fP A new locale.
.RE
.PP
Translations done during I/O which depend on the current locale are changed by this call. The standard adds, \fIBetween invocations of this function a class derived from streambuf can safely cache results of calls to locale functions and to members of facets so obtained.\fP
.PP
\fBNote:\fP
.RS 4
Base class version does nothing. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 855 of file fstream.tcc.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_ext_buf, std::basic_filebuf< _CharT, _Traits >::_M_ext_next, std::basic_filebuf< _CharT, _Traits >::_M_mode, std::basic_filebuf< _CharT, _Traits >::_M_reading, std::basic_filebuf< _CharT, _Traits >::_M_set_buffer(), std::ios_base::cur, std::basic_streambuf< _CharT, _Traits >::eback(), std::basic_streambuf< _CharT, _Traits >::gptr(), and std::basic_filebuf< _CharT, _Traits >::is_open().
.SS "template<typename _CharT, typename _Traits> streamsize \fBstd::basic_streambuf\fP< _CharT, _Traits >::in_avail ()\fC [inline, inherited]\fP"
.PP
Looking ahead into the stream. \fBReturns:\fP
.RS 4
The number of characters available.
.RE
.PP
If a read position is available, returns the number of characters available for reading before the buffer must be refilled. Otherwise returns the derived \fC\fBshowmanyc()\fP\fP. 
.PP
Definition at line 262 of file streambuf.
.SS "template<typename _CharT, typename _Traits> bool \fBstd::basic_filebuf\fP< _CharT, _Traits >::is_open () const  throw ()\fC [inline, inherited]\fP"
.PP
Returns true if the external file is open. 
.PP
Definition at line 222 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::close(), std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_filebuf< _CharT, _Traits >::open(), std::basic_filebuf< _CharT, _Traits >::setbuf(), std::basic_filebuf< _CharT, _Traits >::showmanyc(), and __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf().
.SS "template<typename _CharT , typename _Traits > basic_filebuf< _CharT, _Traits >::\fB__filebuf_type\fP * \fBstd::basic_filebuf\fP< _CharT, _Traits >::open (const char * __s, \fBios_base::openmode\fP __mode)\fC [inherited]\fP"
.PP
Opens an external file. \fBParameters:\fP
.RS 4
\fIs\fP The name of the file. 
.br
\fImode\fP The open mode flags. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP on success, NULL on failure
.RE
.PP
If a file is already open, this function immediately fails. Otherwise it tries to open the file named \fIs\fP using the flags given in \fImode\fP.
.PP
Table 92, adapted here, gives the relation between openmode combinations and the equivalent fopen() flags. (NB: lines app, in|out|app, in|app, binary|app, binary|in|out|app, and binary|in|app per DR 596) +---------------------------------------------------------+ | \fBios_base\fP Flag combination stdio equivalent | |binary in out trunc app | +---------------------------------------------------------+ | + w | | + + a | | + a | | + + w | | + r | | + + r+ | | + + + w+ | | + + + a+ | | + + a+ | +---------------------------------------------------------+ | + + wb | | + + + ab | | + + ab | | + + + wb | | + + rb | | + + + r+b | | + + + + w+b | | + + + + a+b | | + + + a+b | +---------------------------------------------------------+ 
.PP
Definition at line 94 of file fstream.tcc.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_mode, std::basic_filebuf< _CharT, _Traits >::_M_reading, std::basic_filebuf< _CharT, _Traits >::_M_set_buffer(), std::ios_base::ate, std::basic_filebuf< _CharT, _Traits >::close(), std::ios_base::end, and std::basic_filebuf< _CharT, _Traits >::is_open().
.SS "template<typename _CharT, typename _Traits> \fB__filebuf_type\fP* \fBstd::basic_filebuf\fP< _CharT, _Traits >::open (const \fBstd::string\fP & __s, \fBios_base::openmode\fP __mode)\fC [inline, inherited]\fP"
.PP
Opens an external file. \fBParameters:\fP
.RS 4
\fIs\fP The name of the file. 
.br
\fImode\fP The open mode flags. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP on success, NULL on failure 
.RE
.PP

.PP
Definition at line 275 of file fstream.
.PP
Referenced by std::basic_filebuf< char_type, traits_type >::open().
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::overflow (\fBint_type\fP = \fCtraits_type::eof()\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Consumes data from the buffer; writes to the controlled sequence. \fBParameters:\fP
.RS 4
\fIc\fP An additional character to consume. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() to indicate failure, something else (usually \fIc\fP, or not_eof())
.RE
.PP
Informally, this function is called when the output buffer is full (or does not exist, as buffering need not actually be done). If a buffer exists, it is \fIconsumed\fP, with \fIsome effect\fP on the controlled sequence. (Typically, the buffer is written out to the sequence verbatim.) In either case, the character \fIc\fP is also written out, if \fIc\fP is not \fCeof()\fP.
.PP
For a formal definition of this function, see a good text such as Langer & Kreft, or [27.5.2.4.5]/3-7.
.PP
A functioning output streambuf can be created by overriding only this function (no buffer area will be used).
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 746 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbackfail (\fBint_type\fP = \fCtraits_type::eof()\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Tries to back up the input sequence. \fBParameters:\fP
.RS 4
\fIc\fP The character to be inserted back into the sequence. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() on failure, \fIsome other value\fP on success 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The constraints of \fC\fBgptr()\fP\fP, \fC\fBeback()\fP\fP, and \fC\fBpptr()\fP\fP are the same as for \fC\fBunderflow()\fP\fP.
.RE
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 702 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbase () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 507 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::sync().
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbump (int __n)\fC [inline, protected, inherited]\fP"
.PP
Moving the write position. \fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the write position without returning any data. 
.PP
Definition at line 523 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 510 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::sync(), and std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> locale \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubimbue (const \fBlocale\fP & __loc)\fC [inline, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 205 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubseekoff (\fBoff_type\fP __off, \fBios_base::seekdir\fP __way, \fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 239 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubseekpos (\fBpos_type\fP __sp, \fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 244 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fB__streambuf_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubsetbuf (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry points for derived buffer functions. The public versions of \fCpubfoo\fP dispatch to the protected derived \fCfoo\fP member functions, passing the arguments (if any) and returning the result unchanged. 
.PP
Definition at line 235 of file streambuf.
.SS "template<typename _CharT, typename _Traits> int \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubsync ()\fC [inline, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 249 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::sync().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sbumpc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. \fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character and increments the read pointer, otherwise calls and returns \fC\fBuflow()\fP\fP. 
.PP
Definition at line 294 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::getline(), std::basic_istream< _CharT, _Traits >::ignore(), and std::istreambuf_iterator< _CharT, _Traits >::operator++().
.SS "template<typename _CharT, typename _Traits> virtual \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::seekoff (\fBoff_type\fP, \fBios_base::seekdir\fP, \fBios_base::openmode\fP = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Alters the stream positions. Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Definition at line 580 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::seekpos (\fBpos_type\fP, \fBios_base::openmode\fP = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Alters the stream positions. Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Definition at line 592 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual basic_streambuf<\fBchar_type\fP,_Traits>* \fBstd::basic_streambuf\fP< _CharT, _Traits >::setbuf (\fBchar_type\fP *, \fBstreamsize\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Manipulates the buffer. Each derived class provides its own appropriate behavior. See the next-to-last paragraph of http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html for more on this function.
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns \fCthis\fP. 
.RE
.PP

.PP
Definition at line 569 of file streambuf.
.SS "template<typename _CharT , typename _Traits > basic_filebuf< _CharT, _Traits >::\fB__streambuf_type\fP * \fBstd::basic_filebuf\fP< _CharT, _Traits >::setbuf (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Manipulates the buffer. \fBParameters:\fP
.RS 4
\fIs\fP Pointer to a buffer area. 
.br
\fIn\fP Size of \fIs\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP 
.RE
.PP
If no file has been opened, and both \fIs\fP and \fIn\fP are zero, then the stream becomes unbuffered. Otherwise, \fCs\fP is used as a buffer; see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html for more. 
.PP
Definition at line 657 of file fstream.tcc.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_buf, std::basic_filebuf< _CharT, _Traits >::_M_buf_size, and std::basic_filebuf< _CharT, _Traits >::is_open().
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::setg (\fBchar_type\fP * __gbeg, \fBchar_type\fP * __gnext, \fBchar_type\fP * __gend)\fC [inline, protected, inherited]\fP"
.PP
Setting the three read area pointers. \fBParameters:\fP
.RS 4
\fIgbeg\fP A pointer. 
.br
\fIgnext\fP A pointer. 
.br
\fIgend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIgbeg\fP == \fC\fBeback()\fP\fP, \fIgnext\fP == \fC\fBgptr()\fP\fP, and \fIgend\fP == \fC\fBegptr()\fP\fP 
.RE
.PP

.PP
Definition at line 487 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::setp (\fBchar_type\fP * __pbeg, \fBchar_type\fP * __pend)\fC [inline, protected, inherited]\fP"
.PP
Setting the three write area pointers. \fBParameters:\fP
.RS 4
\fIpbeg\fP A pointer. 
.br
\fIpend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIpbeg\fP == \fC\fBpbase()\fP\fP, \fIpbeg\fP == \fC\fBpptr()\fP\fP, and \fIpend\fP == \fC\fBepptr()\fP\fP 
.RE
.PP

.PP
Definition at line 533 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sgetc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. \fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character, otherwise calls and returns \fC\fBunderflow()\fP\fP. Does not move the read position after fetching the character. 
.PP
Definition at line 316 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), std::basic_istream< _CharT, _Traits >::getline(), std::basic_istream< _CharT, _Traits >::ignore(), and std::basic_istream< _CharT, _Traits >::sentry::sentry().
.SS "template<typename _CharT, typename _Traits> streamsize \fBstd::basic_streambuf\fP< _CharT, _Traits >::sgetn (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry point for xsgetn. \fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP A count.
.RE
.PP
Returns xsgetn(s,n). The effect is to fill \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, if possible. 
.PP
Definition at line 335 of file streambuf.
.SS "template<typename _CharT , typename _Traits > streamsize \fBstd::basic_filebuf\fP< _CharT, _Traits >::showmanyc ()\fC [protected, virtual, inherited]\fP"
.PP
Investigating the data available. \fBReturns:\fP
.RS 4
An estimate of the number of characters available in the input sequence, or -1.
.RE
.PP
\fIIf it returns a positive value, then successive calls to \fC\fBunderflow()\fP\fP will not return \fCtraits::eof()\fP until at least that number of characters have been supplied. If \fC\fBshowmanyc()\fP\fP returns -1, then calls to \fC\fBunderflow()\fP\fP or \fC\fBuflow()\fP\fP will fail.\fP [27.5.2.4.3]/1
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.PP
The standard adds that \fIthe intention is not only that the calls [to underflow or uflow] will not return \fCeof()\fP but that they will return immediately.\fP 
.PP
The standard adds that \fIthe morphemes of \fCshowmanyc\fP are \fBes-how-many-see\fP, not \fBshow-manic\fP.\fP 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 178 of file fstream.tcc.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_mode, std::ios_base::binary, std::basic_streambuf< _CharT, _Traits >::egptr(), std::basic_streambuf< _CharT, _Traits >::gptr(), std::ios_base::in, and std::basic_filebuf< _CharT, _Traits >::is_open().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::snextc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. \fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
Calls \fC\fBsbumpc()\fP\fP, and if that function returns \fCtraits::eof()\fP, so does this function. Otherwise, \fC\fBsgetc()\fP\fP. 
.PP
Definition at line 276 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), std::basic_istream< _CharT, _Traits >::getline(), std::basic_istream< _CharT, _Traits >::ignore(), and std::basic_istream< _CharT, _Traits >::sentry::sentry().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputbackc (\fBchar_type\fP __c)\fC [inline, inherited]\fP"
.PP
Pushing characters back into the input stream. \fBParameters:\fP
.RS 4
\fIc\fP The character to push back. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
Similar to \fBsungetc()\fP, but \fIc\fP is pushed onto the stream instead of \fIthe previous character.\fP If successful, the next character fetched from the input stream will be \fIc\fP. 
.PP
Definition at line 350 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::putback().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputc (\fBchar_type\fP __c)\fC [inline, inherited]\fP"
.PP
Entry point for all single-character output functions. \fBParameters:\fP
.RS 4
\fIc\fP A character to output. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIc\fP, if possible.
.RE
.PP
One of two public output functions.
.PP
If a write position is available for the output sequence (i.e., the buffer is not full), stores \fIc\fP in that position, increments the position, and returns \fCtraits::to_int_type(c)\fP. If a write position is not available, returns \fCoverflow(c)\fP. 
.PP
Definition at line 402 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), and std::ostreambuf_iterator< _CharT, _Traits >::operator=().
.SS "template<typename _CharT, typename _Traits> streamsize \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputn (const \fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry point for all single-character output functions. \fBParameters:\fP
.RS 4
\fIs\fP A buffer read area. 
.br
\fIn\fP A count.
.RE
.PP
One of two public output functions.
.PP
Returns xsputn(s,n). The effect is to write \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, if possible. 
.PP
Definition at line 428 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::stossc ()\fC [inline, inherited]\fP"
.PP
Tosses a character. Advances the read pointer, ignoring the character that would have been read.
.PP
See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html 
.PP
Definition at line 761 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sungetc ()\fC [inline, inherited]\fP"
.PP
Moving backwards in the input stream. \fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
If a putback position is available, this function decrements the input pointer and returns that character. Otherwise, calls and returns \fBpbackfail()\fP. The effect is to \fIunget\fP the last character \fIgotten\fP. 
.PP
Definition at line 375 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::unget().
.SS "template<typename _CharT , typename _Traits > int \fBstd::basic_filebuf\fP< _CharT, _Traits >::sync ()\fC [protected, virtual, inherited]\fP"
.PP
Synchronizes the buffer arrays with the controlled sequences. \fBReturns:\fP
.RS 4
-1 on failure.
.RE
.PP
Each derived class provides its own appropriate behavior, including the definition of \fIfailure\fP. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 838 of file fstream.tcc.
.PP
References std::basic_streambuf< _CharT, _Traits >::pbase(), and std::basic_streambuf< _CharT, _Traits >::pptr().
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::uflow ()\fC [inline, protected, virtual, inherited]\fP"
.PP
Fetches more data from the controlled sequence. \fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function does the same thing as \fC\fBunderflow()\fP\fP, and in fact is required to call that function. It also returns the new character, like \fC\fBunderflow()\fP\fP does. However, this function also moves the read position forward by one. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 678 of file streambuf.
.SS "template<typename _CharT , typename _Traits > basic_filebuf< _CharT, _Traits >::\fBint_type\fP \fBstd::basic_filebuf\fP< _CharT, _Traits >::underflow ()\fC [protected, virtual, inherited]\fP"
.PP
Fetches more data from the controlled sequence. \fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function is called when the input buffer is exhausted (or does not exist, as buffering need not actually be done). If a buffer exists, it is \fIrefilled\fP. In either case, the next available character is returned, or \fCtraits::eof()\fP to indicate a null pending sequence.
.PP
For a formal definition of the pending sequence, see a good text such as Langer & Kreft, or [27.5.2.4.3]/7-14.
.PP
A functioning input streambuf can be created by overriding only this function (no buffer area will be used). For an example, see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25.html
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 204 of file fstream.tcc.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_buf_size, std::basic_filebuf< _CharT, _Traits >::_M_destroy_pback(), std::basic_filebuf< _CharT, _Traits >::_M_ext_buf, std::basic_filebuf< _CharT, _Traits >::_M_ext_buf_size, std::basic_filebuf< _CharT, _Traits >::_M_ext_next, std::basic_filebuf< _CharT, _Traits >::_M_mode, std::basic_filebuf< _CharT, _Traits >::_M_reading, std::basic_filebuf< _CharT, _Traits >::_M_set_buffer(), std::basic_streambuf< _CharT, _Traits >::eback(), std::basic_streambuf< _CharT, _Traits >::egptr(), std::basic_streambuf< _CharT, _Traits >::gptr(), std::__codecvt_abstract_base< _InternT, _ExternT, _StateT >::in(), std::ios_base::in, and std::min().
.SS "template<typename _CharT , typename _Traits > streamsize \fBstd::basic_streambuf\fP< _CharT, _Traits >::xsgetn (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Multiple character extraction. \fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to assign. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters assigned.
.RE
.PP
Fills \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, as if by \fC\fBsbumpc()\fP\fP. Stops when either \fIn\fP characters have been copied, or when \fCtraits::eof()\fP would be copied.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 45 of file streambuf.tcc.
.PP
References std::min().
.SS "template<typename _CharT , typename _Traits > streamsize \fBstd::basic_streambuf\fP< _CharT, _Traits >::xsputn (const \fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Multiple character insertion. \fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to write. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters written.
.RE
.PP
Writes \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, as if by \fC\fBsputc()\fP\fP. Stops when either \fIn\fP characters have been copied, or when \fC\fBsputc()\fP\fP would return \fCtraits::eof()\fP.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 79 of file streambuf.tcc.
.PP
References std::basic_streambuf< _CharT, _Traits >::epptr(), std::min(), std::basic_streambuf< _CharT, _Traits >::overflow(), std::basic_streambuf< _CharT, _Traits >::pbump(), and std::basic_streambuf< _CharT, _Traits >::pptr().
.SH "Member Data Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_buf\fP\fC [protected, inherited]\fP"
.PP
Pointer to the beginning of internal buffer. 
.PP
Definition at line 109 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::setbuf().
.SS "template<typename _CharT, typename _Traits> locale \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_buf_locale\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 188 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::basic_filebuf().
.SS "template<typename _CharT, typename _Traits> size_t \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_buf_size\fP\fC [protected, inherited]\fP"Actual size of internal buffer. This number is equal to the size of the put area + 1 position, reserved for the overflow char of a full area. 
.PP
Definition at line 116 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::setbuf(), __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> char* \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_ext_buf\fP\fC [protected, inherited]\fP"Buffer for external characters. Used for input when codecvt::always_noconv() == false. When valid, this corresponds to \fBeback()\fP. 
.PP
Definition at line 151 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> streamsize \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_ext_buf_size\fP\fC [protected, inherited]\fP"Size of buffer held by _M_ext_buf. 
.PP
Definition at line 156 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> const char* \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_ext_next\fP\fC [protected, inherited]\fP"Pointers into the buffer held by _M_ext_buf that delimit a subsequence of bytes that have been read but not yet converted. When valid, _M_ext_next corresponds to \fBegptr()\fP. 
.PP
Definition at line 163 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_beg\fP\fC [protected, inherited]\fP"This is based on _IO_FILE, just reordered to be more consistent, and is intended to be the most minimal abstraction for an internal buffer.
.IP "\(bu" 2
get == input == read
.IP "\(bu" 2
put == output == write 
.PP

.PP
Definition at line 180 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_cur\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 181 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_end\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 182 of file streambuf.
.SS "template<typename _CharT, typename _Traits> ios_base::openmode \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_mode\fP\fC [protected, inherited]\fP"
.PP
Place to stash in || out || in | out settings for current filebuf. 
.PP
Definition at line 94 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_filebuf< _CharT, _Traits >::open(), std::basic_filebuf< _CharT, _Traits >::showmanyc(), __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_beg\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 183 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_cur\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 184 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_end\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 185 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_pback\fP\fC [protected, inherited]\fP"Necessary bits for putback buffer management.
.PP
\fBNote:\fP
.RS 4
pbacks of over one character are not currently supported. 
.RE
.PP

.PP
Definition at line 137 of file fstream.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_pback_cur_save\fP\fC [protected, inherited]\fP"Necessary bits for putback buffer management.
.PP
\fBNote:\fP
.RS 4
pbacks of over one character are not currently supported. 
.RE
.PP

.PP
Definition at line 138 of file fstream.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_pback_end_save\fP\fC [protected, inherited]\fP"Necessary bits for putback buffer management.
.PP
\fBNote:\fP
.RS 4
pbacks of over one character are not currently supported. 
.RE
.PP

.PP
Definition at line 139 of file fstream.
.SS "template<typename _CharT, typename _Traits> bool \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_pback_init\fP\fC [protected, inherited]\fP"Necessary bits for putback buffer management.
.PP
\fBNote:\fP
.RS 4
pbacks of over one character are not currently supported. 
.RE
.PP

.PP
Definition at line 140 of file fstream.
.SS "template<typename _CharT, typename _Traits> bool \fBstd::basic_filebuf\fP< _CharT, _Traits >::\fB_M_reading\fP\fC [protected, inherited]\fP"_M_reading == false && _M_writing == false for \fBuncommitted\fP mode; _M_reading == true for \fBread\fP mode; _M_writing == true for \fBwrite\fP mode;
.PP
NB: _M_reading == true && _M_writing == true is unused. 
.PP
Definition at line 128 of file fstream.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_filebuf< _CharT, _Traits >::open(), __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf(), and std::basic_filebuf< _CharT, _Traits >::underflow().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
