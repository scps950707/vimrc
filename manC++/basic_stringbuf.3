.TH "std::basic_stringbuf" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::basic_stringbuf \- 
.PP
The actual work of input and output (for std::string).
.PP
This class associates either or both of its input and output sequences with a sequence of characters, which can be initialized from, or made available as, a \fC\fBstd::basic_string\fP\fP. (Paraphrased from [27.7.1]/1.).  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef __string_type::size_type \fB__size_type\fP"
.br
.ti -1c
.RI "typedef \fBbasic_streambuf\fP< \fBchar_type\fP, \fBtraits_type\fP > \fB__streambuf_type\fP"
.br
.ti -1c
.RI "typedef \fBbasic_string\fP< \fBchar_type\fP, _Traits, _Alloc > \fB__string_type\fP"
.br
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef _CharT \fBchar_type\fP"
.br
.ti -1c
.RI "typedef traits_type::int_type \fBint_type\fP"
.br
.ti -1c
.RI "typedef traits_type::off_type \fBoff_type\fP"
.br
.ti -1c
.RI "typedef traits_type::pos_type \fBpos_type\fP"
.br
.ti -1c
.RI "typedef _Traits \fBtraits_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbasic_stringbuf\fP (\fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fBbasic_stringbuf\fP (const \fB__string_type\fP &__str, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fBstreamsize\fP \fBin_avail\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsbumpc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsgetc\fP ()"
.br
.ti -1c
.RI "\fBstreamsize\fP \fBsgetn\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsnextc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputbackc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "\fBstreamsize\fP \fBsputn\fP (const \fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "void \fBstossc\fP ()"
.br
.ti -1c
.RI "void \fBstr\fP (const \fB__string_type\fP &__s)"
.br
.ti -1c
.RI "\fB__string_type\fP \fBstr\fP () const "
.br
.ti -1c
.RI "\fBint_type\fP \fBsungetc\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_stringbuf_init\fP (\fBios_base::openmode\fP __mode)"
.br
.ti -1c
.RI "void \fB_M_sync\fP (\fBchar_type\fP *__base, __size_type __i, __size_type __o)"
.br
.ti -1c
.RI "void \fB_M_update_egptr\fP ()"
.br
.ti -1c
.RI "void \fBgbump\fP (int __n)"
.br
.ti -1c
.RI "virtual void \fBimbue\fP (const \fBlocale\fP &)"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBoverflow\fP (\fBint_type\fP __c=traits_type::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBoverflow\fP (\fBint_type\fP=traits_type::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBpbackfail\fP (\fBint_type\fP __c=traits_type::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBpbackfail\fP (\fBint_type\fP=traits_type::eof())"
.br
.ti -1c
.RI "void \fBpbump\fP (int __n)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekoff\fP (\fBoff_type\fP, \fBios_base::seekdir\fP, \fBios_base::openmode\fP=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekoff\fP (\fBoff_type\fP __off, \fBios_base::seekdir\fP __way, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekpos\fP (\fBpos_type\fP __sp, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekpos\fP (\fBpos_type\fP, \fBios_base::openmode\fP=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "virtual \fBbasic_streambuf\fP< \fBchar_type\fP, _Traits > * \fBsetbuf\fP (\fBchar_type\fP *, \fBstreamsize\fP)"
.br
.ti -1c
.RI "virtual \fB__streambuf_type\fP * \fBsetbuf\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "void \fBsetg\fP (\fBchar_type\fP *__gbeg, \fBchar_type\fP *__gnext, \fBchar_type\fP *__gend)"
.br
.ti -1c
.RI "void \fBsetp\fP (\fBchar_type\fP *__pbeg, \fBchar_type\fP *__pend)"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBshowmanyc\fP ()"
.br
.ti -1c
.RI "virtual int \fBsync\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBuflow\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBunderflow\fP ()"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBxsgetn\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBxsputn\fP (const \fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBeback\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBgptr\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBegptr\fP () const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBpbase\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBpptr\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBepptr\fP () const "
.br
.in -1c
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBios_base::openmode\fP \fB_M_mode\fP"
.br
.ti -1c
.RI "\fB__string_type\fP \fB_M_string\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<bool _IsMove, typename _CharT2 > __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, _CharT2 * >::__type \fB__copy_move_a2\fP (\fBistreambuf_iterator\fP< _CharT2 >, \fBistreambuf_iterator\fP< _CharT2 >, _CharT2 *)"
.br
.ti -1c
.RI "\fBstreamsize\fP \fB__copy_streambufs_eof\fP (\fB__streambuf_type\fP *, \fB__streambuf_type\fP *, bool &)"
.br
.ti -1c
.RI "class \fBbasic_ios< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_istream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_ostream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "template<typename _CharT2 > __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, \fBistreambuf_iterator\fP< _CharT2 > >::__type \fBfind\fP (\fBistreambuf_iterator\fP< _CharT2 >, \fBistreambuf_iterator\fP< _CharT2 >, const _CharT2 &)"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 , typename _Alloc > \fBbasic_istream\fP< _CharT2, _Traits2 > & \fBgetline\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, \fBbasic_string\fP< _CharT2, _Traits2, _Alloc > &, _CharT2)"
.br
.ti -1c
.RI "class \fBistreambuf_iterator< char_type, traits_type >\fP"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 , typename _Alloc > \fBbasic_istream\fP< _CharT2, _Traits2 > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, \fBbasic_string\fP< _CharT2, _Traits2, _Alloc > &)"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 > \fBbasic_istream\fP< _CharT2, _Traits2 > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, _CharT2 *)"
.br
.ti -1c
.RI "class \fBostreambuf_iterator< char_type, traits_type >\fP"
.br
.in -1c 
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_end\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_end\fP"
.br
.ti -1c
.RI "\fBlocale\fP \fB_M_buf_locale\fP"
.br
.ti -1c
.RI "\fBlocale\fP \fBpubimbue\fP (const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "\fBlocale\fP \fBgetloc\fP () const "
.br
.ti -1c
.RI "\fB__streambuf_type\fP * \fBpubsetbuf\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekoff\fP (\fBoff_type\fP __off, \fBios_base::seekdir\fP __way, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekpos\fP (\fBpos_type\fP __sp, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "int \fBpubsync\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT, typename _Traits, typename _Alloc> class std::basic_stringbuf< _CharT, _Traits, _Alloc >"
The actual work of input and output (for std::string).
.PP
This class associates either or both of its input and output sequences with a sequence of characters, which can be initialized from, or made available as, a \fC\fBstd::basic_string\fP\fP. (Paraphrased from [27.7.1]/1.). 

For this class, open modes (of type \fC\fBios_base::openmode\fP\fP) have \fCin\fP set if the input sequence can be read, and \fCout\fP set if the output sequence can be written. 
.PP
Definition at line 58 of file sstream.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef \fBbasic_streambuf\fP<\fBchar_type\fP, \fBtraits_type\fP> \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fB__streambuf_type\fP"
.PP
This is a non-standard type. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 71 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef _CharT \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBchar_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 62 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef traits_type::int_type \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBint_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 67 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef traits_type::off_type \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBoff_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 69 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef traits_type::pos_type \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBpos_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 68 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef _Traits \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBtraits_type\fP"These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 63 of file sstream.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits, typename _Alloc> \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBbasic_stringbuf\fP (\fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, explicit]\fP"
.PP
Starts with an empty string buffer. \fBParameters:\fP
.RS 4
\fImode\fP Whether the buffer can read, or write, or both.
.RE
.PP
The default constructor initializes the parent class using its own default ctor. 
.PP
Definition at line 92 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBbasic_stringbuf\fP (const \fB__string_type\fP & __str, \fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, explicit]\fP"
.PP
Starts with an existing string buffer. \fBParameters:\fP
.RS 4
\fIstr\fP A string to copy as a starting buffer. 
.br
\fImode\fP Whether the buffer can read, or write, or both.
.RE
.PP
This constructor initializes the parent class using its own default ctor. 
.PP
Definition at line 105 of file sstream.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::eback () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 460 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::egptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 466 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::showmanyc(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::epptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 513 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::gbump (int __n)\fC [inline, protected, inherited]\fP"
.PP
Moving the read position. \fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the read position without returning any data. 
.PP
Definition at line 476 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBlocale\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::getloc () const\fC [inline, inherited]\fP"
.PP
Locale access. \fBReturns:\fP
.RS 4
The current locale in effect.
.RE
.PP
If pubimbue(loc) has been called, then the most recent \fCloc\fP is returned. Otherwise the global locale in effect at the time of construction is returned. 
.PP
Definition at line 222 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::gptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 463 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_filebuf< _CharT, _Traits >::showmanyc(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow(), and std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _CharT, typename _Traits> virtual void \fBstd::basic_streambuf\fP< _CharT, _Traits >::imbue (const \fBlocale\fP &)\fC [inline, protected, virtual, inherited]\fP"
.PP
Changes translations. \fBParameters:\fP
.RS 4
\fIloc\fP A new locale.
.RE
.PP
Translations done during I/O which depend on the current locale are changed by this call. The standard adds, \fIBetween invocations of this function a class derived from streambuf can safely cache results of calls to locale functions and to members of facets so obtained.\fP
.PP
\fBNote:\fP
.RS 4
Base class version does nothing. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP, and \fBstd::basic_filebuf< char_type, traits_type >\fP.
.PP
Definition at line 554 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::in_avail ()\fC [inline, inherited]\fP"
.PP
Looking ahead into the stream. \fBReturns:\fP
.RS 4
The number of characters available.
.RE
.PP
If a read position is available, returns the number of characters available for reading before the buffer must be refilled. Otherwise returns the derived \fC\fBshowmanyc()\fP\fP. 
.PP
Definition at line 262 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::overflow (\fBint_type\fP = \fCtraits_type::eof()\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Consumes data from the buffer; writes to the controlled sequence. \fBParameters:\fP
.RS 4
\fIc\fP An additional character to consume. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() to indicate failure, something else (usually \fIc\fP, or not_eof())
.RE
.PP
Informally, this function is called when the output buffer is full (or does not exist, as buffering need not actually be done). If a buffer exists, it is \fIconsumed\fP, with \fIsome effect\fP on the controlled sequence. (Typically, the buffer is written out to the sequence verbatim.) In either case, the character \fIc\fP is also written out, if \fIc\fP is not \fCeof()\fP.
.PP
For a formal definition of this function, see a good text such as Langer & Kreft, or [27.5.2.4.5]/3-7.
.PP
A functioning output streambuf can be created by overriding only this function (no buffer area will be used).
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 746 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbackfail (\fBint_type\fP = \fCtraits_type::eof()\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Tries to back up the input sequence. \fBParameters:\fP
.RS 4
\fIc\fP The character to be inserted back into the sequence. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() on failure, \fIsome other value\fP on success 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The constraints of \fC\fBgptr()\fP\fP, \fC\fBeback()\fP\fP, and \fC\fBpptr()\fP\fP are the same as for \fC\fBunderflow()\fP\fP.
.RE
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 702 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbase () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 507 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::sync().
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbump (int __n)\fC [inline, protected, inherited]\fP"
.PP
Moving the write position. \fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the write position without returning any data. 
.PP
Definition at line 523 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 510 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::sync(), and std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> \fBlocale\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubimbue (const \fBlocale\fP & __loc)\fC [inline, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 205 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubseekoff (\fBoff_type\fP __off, \fBios_base::seekdir\fP __way, \fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 239 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubseekpos (\fBpos_type\fP __sp, \fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 244 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fB__streambuf_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubsetbuf (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry points for derived buffer functions. The public versions of \fCpubfoo\fP dispatch to the protected derived \fCfoo\fP member functions, passing the arguments (if any) and returning the result unchanged. 
.PP
Definition at line 235 of file streambuf.
.SS "template<typename _CharT, typename _Traits> int \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubsync ()\fC [inline, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 249 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::sync().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sbumpc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. \fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character and increments the read pointer, otherwise calls and returns \fC\fBuflow()\fP\fP. 
.PP
Definition at line 294 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::getline(), std::basic_istream< _CharT, _Traits >::ignore(), and std::istreambuf_iterator< _CharT, _Traits >::operator++().
.SS "template<typename _CharT, typename _Traits> virtual \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::seekoff (\fBoff_type\fP, \fBios_base::seekdir\fP, \fBios_base::openmode\fP = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Alters the stream positions. Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Definition at line 580 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::seekpos (\fBpos_type\fP, \fBios_base::openmode\fP = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Alters the stream positions. Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Definition at line 592 of file streambuf.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> virtual \fB__streambuf_type\fP* \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::setbuf (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, protected, virtual]\fP"
.PP
Manipulates the buffer. \fBParameters:\fP
.RS 4
\fIs\fP Pointer to a buffer area. 
.br
\fIn\fP Size of \fIs\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP 
.RE
.PP
If no buffer has already been created, and both \fIs\fP and \fIn\fP are non-zero, then \fCs\fP is used as a buffer; see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html for more. 
.PP
Definition at line 196 of file sstream.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::clear().
.SS "template<typename _CharT, typename _Traits> virtual \fBbasic_streambuf\fP<\fBchar_type\fP,_Traits>* \fBstd::basic_streambuf\fP< _CharT, _Traits >::setbuf (\fBchar_type\fP *, \fBstreamsize\fP)\fC [inline, protected, virtual, inherited]\fP"
.PP
Manipulates the buffer. Each derived class provides its own appropriate behavior. See the next-to-last paragraph of http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html for more on this function.
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns \fCthis\fP. 
.RE
.PP

.PP
Definition at line 569 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::setg (\fBchar_type\fP * __gbeg, \fBchar_type\fP * __gnext, \fBchar_type\fP * __gend)\fC [inline, protected, inherited]\fP"
.PP
Setting the three read area pointers. \fBParameters:\fP
.RS 4
\fIgbeg\fP A pointer. 
.br
\fIgnext\fP A pointer. 
.br
\fIgend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIgbeg\fP == \fC\fBeback()\fP\fP, \fIgnext\fP == \fC\fBgptr()\fP\fP, and \fIgend\fP == \fC\fBegptr()\fP\fP 
.RE
.PP

.PP
Definition at line 487 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::setp (\fBchar_type\fP * __pbeg, \fBchar_type\fP * __pend)\fC [inline, protected, inherited]\fP"
.PP
Setting the three write area pointers. \fBParameters:\fP
.RS 4
\fIpbeg\fP A pointer. 
.br
\fIpend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIpbeg\fP == \fC\fBpbase()\fP\fP, \fIpbeg\fP == \fC\fBpptr()\fP\fP, and \fIpend\fP == \fC\fBepptr()\fP\fP 
.RE
.PP

.PP
Definition at line 533 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sgetc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. \fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character, otherwise calls and returns \fC\fBunderflow()\fP\fP. Does not move the read position after fetching the character. 
.PP
Definition at line 316 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), std::basic_istream< _CharT, _Traits >::getline(), std::basic_istream< _CharT, _Traits >::ignore(), and std::basic_istream< _CharT, _Traits >::sentry::sentry().
.SS "template<typename _CharT, typename _Traits> \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sgetn (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry point for xsgetn. \fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP A count.
.RE
.PP
Returns xsgetn(s,n). The effect is to fill \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, if possible. 
.PP
Definition at line 335 of file streambuf.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> virtual \fBstreamsize\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::showmanyc ()\fC [inline, protected, virtual]\fP"
.PP
Investigating the data available. \fBReturns:\fP
.RS 4
An estimate of the number of characters available in the input sequence, or -1.
.RE
.PP
\fIIf it returns a positive value, then successive calls to \fC\fBunderflow()\fP\fP will not return \fCtraits::eof()\fP until at least that number of characters have been supplied. If \fC\fBshowmanyc()\fP\fP returns -1, then calls to \fC\fBunderflow()\fP\fP or \fC\fBuflow()\fP\fP will fail.\fP [27.5.2.4.3]/1
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.PP
The standard adds that \fIthe intention is not only that the calls [to underflow or uflow] will not return \fCeof()\fP but that they will return immediately.\fP 
.PP
The standard adds that \fIthe morphemes of \fCshowmanyc\fP are \fBes-how-many-see\fP, not \fBshow-manic\fP.\fP 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 164 of file sstream.
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::snextc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. \fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
Calls \fC\fBsbumpc()\fP\fP, and if that function returns \fCtraits::eof()\fP, so does this function. Otherwise, \fC\fBsgetc()\fP\fP. 
.PP
Definition at line 276 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), std::basic_istream< _CharT, _Traits >::getline(), std::basic_istream< _CharT, _Traits >::ignore(), and std::basic_istream< _CharT, _Traits >::sentry::sentry().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputbackc (\fBchar_type\fP __c)\fC [inline, inherited]\fP"
.PP
Pushing characters back into the input stream. \fBParameters:\fP
.RS 4
\fIc\fP The character to push back. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
Similar to \fBsungetc()\fP, but \fIc\fP is pushed onto the stream instead of \fIthe previous character.\fP If successful, the next character fetched from the input stream will be \fIc\fP. 
.PP
Definition at line 350 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::putback().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputc (\fBchar_type\fP __c)\fC [inline, inherited]\fP"
.PP
Entry point for all single-character output functions. \fBParameters:\fP
.RS 4
\fIc\fP A character to output. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIc\fP, if possible.
.RE
.PP
One of two public output functions.
.PP
If a write position is available for the output sequence (i.e., the buffer is not full), stores \fIc\fP in that position, increments the position, and returns \fCtraits::to_int_type(c)\fP. If a write position is not available, returns \fCoverflow(c)\fP. 
.PP
Definition at line 402 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), and std::ostreambuf_iterator< _CharT, _Traits >::operator=().
.SS "template<typename _CharT, typename _Traits> \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputn (const \fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry point for all single-character output functions. \fBParameters:\fP
.RS 4
\fIs\fP A buffer read area. 
.br
\fIn\fP A count.
.RE
.PP
One of two public output functions.
.PP
Returns xsputn(s,n). The effect is to write \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, if possible. 
.PP
Definition at line 428 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::stossc ()\fC [inline, inherited]\fP"
.PP
Tosses a character. Advances the read pointer, ignoring the character that would have been read.
.PP
See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html 
.PP
Definition at line 761 of file streambuf.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> void \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::str (const \fB__string_type\fP & __s)\fC [inline]\fP"
.PP
Setting a new buffer. \fBParameters:\fP
.RS 4
\fIs\fP The string to use as a new sequence.
.RE
.PP
Deallocates any previous stored sequence, then copies \fIs\fP to use as a new one. 
.PP
Definition at line 144 of file sstream.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::assign(), std::basic_string< _CharT, _Traits, _Alloc >::data(), and std::basic_string< _CharT, _Traits, _Alloc >::size().
.SS "template<typename _CharT, typename _Traits, typename _Alloc> \fB__string_type\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::str () const\fC [inline]\fP"
.PP
Copying out the string buffer. \fBReturns:\fP
.RS 4
A copy of one of the underlying sequences.
.RE
.PP
\fIIf the buffer is only created in input mode, the underlying character sequence is equal to the input sequence; otherwise, it is equal to the output sequence.\fP [27.7.1.2]/1 
.PP
Definition at line 120 of file sstream.
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sungetc ()\fC [inline, inherited]\fP"
.PP
Moving backwards in the input stream. \fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
If a putback position is available, this function decrements the input pointer and returns that character. Otherwise, calls and returns \fBpbackfail()\fP. The effect is to \fIunget\fP the last character \fIgotten\fP. 
.PP
Definition at line 375 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::unget().
.SS "template<typename _CharT, typename _Traits> virtual int \fBstd::basic_streambuf\fP< _CharT, _Traits >::sync (void)\fC [inline, protected, virtual, inherited]\fP"
.PP
Synchronizes the buffer arrays with the controlled sequences. \fBReturns:\fP
.RS 4
-1 on failure.
.RE
.PP
Each derived class provides its own appropriate behavior, including the definition of \fIfailure\fP. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP, and \fBstd::basic_filebuf< char_type, traits_type >\fP.
.PP
Definition at line 605 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::uflow ()\fC [inline, protected, virtual, inherited]\fP"
.PP
Fetches more data from the controlled sequence. \fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function does the same thing as \fC\fBunderflow()\fP\fP, and in fact is required to call that function. It also returns the new character, like \fC\fBunderflow()\fP\fP does. However, this function also moves the read position forward by one. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 678 of file streambuf.
.SS "template<class _CharT , class _Traits , class _Alloc > \fBbasic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBint_type\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::underflow ()\fC [protected, virtual]\fP"
.PP
Fetches more data from the controlled sequence. \fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function is called when the input buffer is exhausted (or does not exist, as buffering need not actually be done). If a buffer exists, it is \fIrefilled\fP. In either case, the next available character is returned, or \fCtraits::eof()\fP to indicate a null pending sequence.
.PP
For a formal definition of the pending sequence, see a good text such as Langer & Kreft, or [27.5.2.4.3]/7-14.
.PP
A functioning input streambuf can be created by overriding only this function (no buffer area will be used). For an example, see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25.html
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 131 of file sstream.tcc.
.PP
References std::basic_stringbuf< _CharT, _Traits, _Alloc >::_M_mode, std::basic_streambuf< _CharT, _Traits >::egptr(), std::basic_streambuf< _CharT, _Traits >::gptr(), and std::ios_base::in.
.SS "template<typename _CharT , typename _Traits > \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::xsgetn (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Multiple character extraction. \fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to assign. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters assigned.
.RE
.PP
Fills \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, as if by \fC\fBsbumpc()\fP\fP. Stops when either \fIn\fP characters have been copied, or when \fCtraits::eof()\fP would be copied.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 45 of file streambuf.tcc.
.PP
References std::min().
.SS "template<typename _CharT , typename _Traits > \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::xsputn (const \fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Multiple character insertion. \fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to write. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters written.
.RE
.PP
Writes \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, as if by \fC\fBsputc()\fP\fP. Stops when either \fIn\fP characters have been copied, or when \fC\fBsputc()\fP\fP would return \fCtraits::eof()\fP.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 79 of file streambuf.tcc.
.PP
References std::basic_streambuf< _CharT, _Traits >::epptr(), std::min(), std::basic_streambuf< _CharT, _Traits >::overflow(), std::basic_streambuf< _CharT, _Traits >::pbump(), and std::basic_streambuf< _CharT, _Traits >::pptr().
.SH "Member Data Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> \fBlocale\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_buf_locale\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 188 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::basic_filebuf().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_beg\fP\fC [protected, inherited]\fP"This is based on _IO_FILE, just reordered to be more consistent, and is intended to be the most minimal abstraction for an internal buffer.
.IP "\(bu" 2
get == input == read
.IP "\(bu" 2
put == output == write 
.PP

.PP
Definition at line 180 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_cur\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 181 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_end\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 182 of file streambuf.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> \fBios_base::openmode\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fB_M_mode\fP\fC [protected]\fP"
.PP
Place to stash in || out || in | out settings for current stringbuf. 
.PP
Definition at line 77 of file sstream.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_beg\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 183 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_cur\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 184 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_end\fP\fC [protected, inherited]\fP"
.PP
Entry point for \fBimbue()\fP. \fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 185 of file streambuf.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
