.TH "__gnu_parallel" 3 "Sun Oct 10 2010" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_parallel \- 
.PP
GNU parallel code for public use.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fB__accumulate_binop_reduct\fP"
.br
.RI "\fIGeneral reduction, using a binary operator. \fP"
.ti -1c
.RI "struct \fB__accumulate_selector\fP"
.br
.RI "\fI\fBstd::accumulate()\fP selector. \fP"
.ti -1c
.RI "struct \fB__adjacent_difference_selector\fP"
.br
.RI "\fISelector that returns the difference between two adjacent __elements. \fP"
.ti -1c
.RI "struct \fB__adjacent_find_selector\fP"
.br
.RI "\fITest predicate on two adjacent elements. \fP"
.ti -1c
.RI "class \fB__binder1st\fP"
.br
.RI "\fISimilar to \fBstd::binder1st\fP, but giving the argument types explicitly. \fP"
.ti -1c
.RI "class \fB__binder2nd\fP"
.br
.RI "\fISimilar to \fBstd::binder2nd\fP, but giving the argument types explicitly. \fP"
.ti -1c
.RI "struct \fB__count_if_selector\fP"
.br
.RI "\fIstd::count_if () selector. \fP"
.ti -1c
.RI "struct \fB__count_selector\fP"
.br
.RI "\fIstd::count() selector. \fP"
.ti -1c
.RI "struct \fB__fill_selector\fP"
.br
.RI "\fIstd::fill() selector. \fP"
.ti -1c
.RI "struct \fB__find_first_of_selector\fP"
.br
.RI "\fITest predicate on several elements. \fP"
.ti -1c
.RI "struct \fB__find_if_selector\fP"
.br
.RI "\fITest predicate on a single element, used for std::find() and std::find_if (). \fP"
.ti -1c
.RI "struct \fB__for_each_selector\fP"
.br
.RI "\fIstd::for_each() selector. \fP"
.ti -1c
.RI "struct \fB__generate_selector\fP"
.br
.RI "\fIstd::generate() selector. \fP"
.ti -1c
.RI "struct \fB__generic_find_selector\fP"
.br
.RI "\fIBase class of all \fB__gnu_parallel::__find_template\fP selectors. \fP"
.ti -1c
.RI "struct \fB__generic_for_each_selector\fP"
.br
.RI "\fIGeneric __selector for embarrassingly parallel functions. \fP"
.ti -1c
.RI "struct \fB__identity_selector\fP"
.br
.RI "\fISelector that just returns the passed iterator. \fP"
.ti -1c
.RI "struct \fB__inner_product_selector\fP"
.br
.RI "\fI\fBstd::inner_product()\fP selector. \fP"
.ti -1c
.RI "struct \fB__max_element_reduct\fP"
.br
.RI "\fIReduction for finding the maximum element, using a comparator. \fP"
.ti -1c
.RI "struct \fB__min_element_reduct\fP"
.br
.RI "\fIReduction for finding the maximum element, using a comparator. \fP"
.ti -1c
.RI "struct \fB__mismatch_selector\fP"
.br
.RI "\fITest inverted predicate on a single element. \fP"
.ti -1c
.RI "struct \fB__multiway_merge_3_variant_sentinel_switch\fP"
.br
.RI "\fISwitch for 3-way merging with __sentinels turned off. \fP"
.ti -1c
.RI "struct \fB__multiway_merge_3_variant_sentinel_switch< true, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare >\fP"
.br
.RI "\fISwitch for 3-way merging with __sentinels turned on. \fP"
.ti -1c
.RI "struct \fB__multiway_merge_4_variant_sentinel_switch\fP"
.br
.RI "\fISwitch for 4-way merging with __sentinels turned off. \fP"
.ti -1c
.RI "struct \fB__multiway_merge_4_variant_sentinel_switch< true, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare >\fP"
.br
.RI "\fISwitch for 4-way merging with __sentinels turned on. \fP"
.ti -1c
.RI "struct \fB__multiway_merge_k_variant_sentinel_switch\fP"
.br
.RI "\fISwitch for k-way merging with __sentinels turned on. \fP"
.ti -1c
.RI "struct \fB__multiway_merge_k_variant_sentinel_switch< false, __stable, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare >\fP"
.br
.RI "\fISwitch for k-way merging with __sentinels turned off. \fP"
.ti -1c
.RI "struct \fB__replace_if_selector\fP"
.br
.RI "\fIstd::replace() selector. \fP"
.ti -1c
.RI "struct \fB__replace_selector\fP"
.br
.RI "\fIstd::replace() selector. \fP"
.ti -1c
.RI "struct \fB__transform1_selector\fP"
.br
.RI "\fIstd::transform() __selector, one input sequence variant. \fP"
.ti -1c
.RI "struct \fB__transform2_selector\fP"
.br
.RI "\fIstd::transform() __selector, two input sequences variant. \fP"
.ti -1c
.RI "class \fB__unary_negate\fP"
.br
.RI "\fISimilar to \fBstd::unary_negate\fP, but giving the argument types explicitly. \fP"
.ti -1c
.RI "struct \fB_DRandomShufflingGlobalData\fP"
.br
.RI "\fIData known to every thread participating in \fB__gnu_parallel::__parallel_random_shuffle()\fP. \fP"
.ti -1c
.RI "struct \fB_DRSSorterPU\fP"
.br
.RI "\fILocal data for a thread participating in \fB__gnu_parallel::__parallel_random_shuffle()\fP. \fP"
.ti -1c
.RI "struct \fB_DummyReduct\fP"
.br
.RI "\fIReduction function doing nothing. \fP"
.ti -1c
.RI "class \fB_EqualFromLess\fP"
.br
.RI "\fIConstructs predicate for equality from strict weak ordering predicate. \fP"
.ti -1c
.RI "struct \fB_EqualTo\fP"
.br
.RI "\fISimilar to \fBstd::equal_to\fP, but allows two different types. \fP"
.ti -1c
.RI "class \fB_GuardedIterator\fP"
.br
.RI "\fI_Iterator wrapper supporting an implicit supremum at the end of the sequence, dominating all comparisons. \fP"
.ti -1c
.RI "class \fB_IteratorPair\fP"
.br
.RI "\fIA pair of iterators. The usual iterator operations are applied to both child iterators. \fP"
.ti -1c
.RI "class \fB_IteratorTriple\fP"
.br
.RI "\fIA triple of iterators. The usual iterator operations are applied to all three child iterators. \fP"
.ti -1c
.RI "struct \fB_Job\fP"
.br
.RI "\fIOne __job for a certain thread. \fP"
.ti -1c
.RI "struct \fB_Less\fP"
.br
.RI "\fISimilar to \fBstd::less\fP, but allows two different types. \fP"
.ti -1c
.RI "class \fB_Lexicographic\fP"
.br
.RI "\fICompare __a pair of types lexicographically, ascending. \fP"
.ti -1c
.RI "class \fB_LexicographicReverse\fP"
.br
.RI "\fICompare __a pair of types lexicographically, descending. \fP"
.ti -1c
.RI "class \fB_LoserTree\fP"
.br
.RI "\fIStable \fB_LoserTree\fP variant. \fP"
.ti -1c
.RI "class \fB_LoserTree< false, _Tp, _Compare >\fP"
.br
.RI "\fIUnstable \fB_LoserTree\fP variant. \fP"
.ti -1c
.RI "class \fB_LoserTreeBase\fP"
.br
.RI "\fIGuarded loser/tournament tree. \fP"
.ti -1c
.RI "class \fB_LoserTreePointer\fP"
.br
.RI "\fIStable \fB_LoserTree\fP implementation. \fP"
.ti -1c
.RI "class \fB_LoserTreePointer< false, _Tp, _Compare >\fP"
.br
.RI "\fIUnstable \fB_LoserTree\fP implementation. \fP"
.ti -1c
.RI "class \fB_LoserTreePointerBase\fP"
.br
.RI "\fIBase class of \fB_Loser\fP Tree implementation using pointers. \fP"
.ti -1c
.RI "class \fB_LoserTreePointerUnguarded\fP"
.br
.RI "\fIStable unguarded \fB_LoserTree\fP variant storing pointers. \fP"
.ti -1c
.RI "class \fB_LoserTreePointerUnguarded< false, _Tp, _Compare >\fP"
.br
.RI "\fIUnstable unguarded \fB_LoserTree\fP variant storing pointers. \fP"
.ti -1c
.RI "class \fB_LoserTreePointerUnguardedBase\fP"
.br
.RI "\fIUnguarded loser tree, keeping only pointers to the elements in the tree structure. \fP"
.ti -1c
.RI "struct \fB_LoserTreeTraits\fP"
.br
.RI "\fITraits for determining whether the loser tree should use pointers or copies. \fP"
.ti -1c
.RI "class \fB_LoserTreeUnguarded\fP"
.br
.RI "\fIStable implementation of unguarded \fB_LoserTree\fP. \fP"
.ti -1c
.RI "class \fB_LoserTreeUnguarded< false, _Tp, _Compare >\fP"
.br
.RI "\fINon-Stable implementation of unguarded \fB_LoserTree\fP. \fP"
.ti -1c
.RI "class \fB_LoserTreeUnguardedBase\fP"
.br
.RI "\fIBase class for unguarded \fB_LoserTree\fP implementation. \fP"
.ti -1c
.RI "struct \fB_Multiplies\fP"
.br
.RI "\fISimilar to \fBstd::multiplies\fP, but allows two different types. \fP"
.ti -1c
.RI "struct \fB_Nothing\fP"
.br
.RI "\fIFunctor doing nothing. \fP"
.ti -1c
.RI "struct \fB_Piece\fP"
.br
.RI "\fISubsequence description. \fP"
.ti -1c
.RI "struct \fB_Plus\fP"
.br
.RI "\fISimilar to \fBstd::plus\fP, but allows two different types. \fP"
.ti -1c
.RI "struct \fB_PMWMSSortingData\fP"
.br
.RI "\fIData accessed by all threads. \fP"
.ti -1c
.RI "class \fB_PseudoSequence\fP"
.br
.RI "\fISequence that conceptually consists of multiple copies of the same element. The copies are not stored explicitly, of course. \fP"
.ti -1c
.RI "class \fB_PseudoSequenceIterator\fP"
.br
.RI "\fI_Iterator associated with \fB__gnu_parallel::_PseudoSequence\fP. If features the usual random-access iterator functionality. \fP"
.ti -1c
.RI "struct \fB_QSBThreadLocal\fP"
.br
.RI "\fIInformation local to one thread in the parallel quicksort run. \fP"
.ti -1c
.RI "class \fB_RandomNumber\fP"
.br
.RI "\fIRandom number generator, based on the Mersenne twister. \fP"
.ti -1c
.RI "class \fB_RestrictedBoundedConcurrentQueue\fP"
.br
.RI "\fIDouble-ended queue of bounded size, allowing lock-free atomic access. \fBpush_front()\fP and \fBpop_front()\fP must not be called concurrently to each other, while \fBpop_back()\fP can be called concurrently at all times. \fCempty()\fP, \fCsize()\fP, and \fCtop()\fP are intentionally not provided. Calling them would not make sense in a concurrent setting. \fP"
.ti -1c
.RI "struct \fB_SamplingSorter\fP"
.br
.RI "\fIStable sorting functor. \fP"
.ti -1c
.RI "struct \fB_SamplingSorter< false, _RAIter, _StrictWeakOrdering >\fP"
.br
.RI "\fINon-__stable sorting functor. \fP"
.ti -1c
.RI "struct \fB_Settings\fP"
.br
.RI "\fIclass \fB_Settings\fP /// Run-time settings for the parallel mode including all tunable parameters. \fP"
.ti -1c
.RI "struct \fB_SplitConsistently\fP"
.br
.RI "\fISplit consistently. \fP"
.ti -1c
.RI "struct \fB_SplitConsistently< false, _RAIter, _Compare, _SortingPlacesIterator >\fP"
.br
.RI "\fISplit by sampling. \fP"
.ti -1c
.RI "struct \fB_SplitConsistently< true, _RAIter, _Compare, _SortingPlacesIterator >\fP"
.br
.RI "\fISplit by exact splitting. \fP"
.ti -1c
.RI "struct \fBbalanced_quicksort_tag\fP"
.br
.RI "\fIForces parallel sorting using balanced quicksort at compile time. \fP"
.ti -1c
.RI "struct \fBbalanced_tag\fP"
.br
.RI "\fIRecommends parallel execution using dynamic load-balancing at compile time. \fP"
.ti -1c
.RI "struct \fBconstant_size_blocks_tag\fP"
.br
.RI "\fISelects the constant block size variant for std::find(). \fP"
.ti -1c
.RI "struct \fBdefault_parallel_tag\fP"
.br
.RI "\fIRecommends parallel execution using the default parallel algorithm. \fP"
.ti -1c
.RI "struct \fBequal_split_tag\fP"
.br
.RI "\fISelects the equal splitting variant for std::find(). \fP"
.ti -1c
.RI "struct \fBexact_tag\fP"
.br
.RI "\fIForces parallel merging with exact splitting, at compile time. \fP"
.ti -1c
.RI "struct \fBfind_tag\fP"
.br
.RI "\fIBase class for for std::find() variants. \fP"
.ti -1c
.RI "struct \fBgrowing_blocks_tag\fP"
.br
.RI "\fISelects the growing block size variant for std::find(). \fP"
.ti -1c
.RI "struct \fBmultiway_mergesort_exact_tag\fP"
.br
.RI "\fIForces parallel sorting using multiway mergesort with exact splitting at compile time. \fP"
.ti -1c
.RI "struct \fBmultiway_mergesort_sampling_tag\fP"
.br
.RI "\fIForces parallel sorting using multiway mergesort with splitting by sampling at compile time. \fP"
.ti -1c
.RI "struct \fBmultiway_mergesort_tag\fP"
.br
.RI "\fIForces parallel sorting using multiway mergesort at compile time. \fP"
.ti -1c
.RI "struct \fBomp_loop_static_tag\fP"
.br
.RI "\fIRecommends parallel execution using OpenMP static load-balancing at compile time. \fP"
.ti -1c
.RI "struct \fBomp_loop_tag\fP"
.br
.RI "\fIRecommends parallel execution using OpenMP dynamic load-balancing at compile time. \fP"
.ti -1c
.RI "struct \fBparallel_tag\fP"
.br
.RI "\fIRecommends parallel execution at compile time, optionally using a user-specified number of threads. \fP"
.ti -1c
.RI "struct \fBquicksort_tag\fP"
.br
.RI "\fIForces parallel sorting using unbalanced quicksort at compile time. \fP"
.ti -1c
.RI "struct \fBsampling_tag\fP"
.br
.RI "\fIForces parallel merging with exact splitting, at compile time. \fP"
.ti -1c
.RI "struct \fBsequential_tag\fP"
.br
.RI "\fIForces sequential execution at compile time. \fP"
.ti -1c
.RI "struct \fBunbalanced_tag\fP"
.br
.RI "\fIRecommends parallel execution using static load-balancing at compile time. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned short \fB_BinIndex\fP"
.br
.ti -1c
.RI "typedef int64_t \fB_CASable\fP"
.br
.ti -1c
.RI "typedef uint64_t \fB_SequenceIndex\fP"
.br
.ti -1c
.RI "typedef uint16_t \fB_ThreadIndex\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB_AlgorithmStrategy\fP { \fBheuristic\fP, \fBforce_sequential\fP, \fBforce_parallel\fP }"
.br
.ti -1c
.RI "enum \fB_FindAlgorithm\fP { \fBGROWING_BLOCKS\fP, \fBCONSTANT_SIZE_BLOCKS\fP, \fBEQUAL_SPLIT\fP }"
.br
.ti -1c
.RI "enum \fB_MultiwayMergeAlgorithm\fP { \fBLOSER_TREE\fP }"
.br
.ti -1c
.RI "enum \fB_Parallelism\fP { \fBsequential\fP, \fBparallel_unbalanced\fP, \fBparallel_balanced\fP, \fBparallel_omp_loop\fP, \fBparallel_omp_loop_static\fP, \fBparallel_taskqueue\fP }"
.br
.ti -1c
.RI "enum \fB_PartialSumAlgorithm\fP { \fBRECURSIVE\fP, \fBLINEAR\fP }"
.br
.ti -1c
.RI "enum \fB_SortAlgorithm\fP { \fBMWMS\fP, \fBQS\fP, \fBQS_BALANCED\fP }"
.br
.ti -1c
.RI "enum \fB_SplittingAlgorithm\fP { \fBSAMPLING\fP, \fBEXACT\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _RAIter , typename _DifferenceTp > void \fB__calc_borders\fP (_RAIter __elements, _DifferenceTp __length, _DifferenceTp *__off)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fB__compare_and_swap\fP (volatile _Tp *__ptr, _Tp __comparand, _Tp __replacement)"
.br
.ti -1c
.RI "bool \fB__compare_and_swap_32\fP (volatile int32_t *__ptr, int32_t __comparand, int32_t __replacement)"
.br
.ti -1c
.RI "bool \fB__compare_and_swap_64\fP (volatile int64_t *__ptr, int64_t __comparand, int64_t __replacement)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator > _OutputIterator \fB__copy_tail\fP (\fBstd::pair\fP< _IIter, _IIter > __b, \fBstd::pair\fP< _IIter, _IIter > __e, _OutputIterator __r)"
.br
.ti -1c
.RI "void \fB__decode2\fP (\fB_CASable\fP __x, int &__a, int &__b)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _DifferenceTp > void \fB__determine_samples\fP (\fB_PMWMSSortingData\fP< _RAIter > *__sd, _DifferenceTp __num_samples)"
.br
.ti -1c
.RI "\fB_CASable\fP \fB__encode2\fP (int __a, int __b)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fB__fetch_and_add\fP (volatile _Tp *__ptr, _Tp __addend)"
.br
.ti -1c
.RI "int32_t \fB__fetch_and_add_32\fP (volatile int32_t *__ptr, int32_t __addend)"
.br
.ti -1c
.RI "int64_t \fB__fetch_and_add_64\fP (volatile int64_t *__ptr, int64_t __addend)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector > \fBstd::pair\fP< _RAIter1, _RAIter2 > \fB__find_template\fP (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred __pred, _Selector __selector)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector > \fBstd::pair\fP< _RAIter1, _RAIter2 > \fB__find_template\fP (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred __pred, _Selector __selector, \fBequal_split_tag\fP)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector > \fBstd::pair\fP< _RAIter1, _RAIter2 > \fB__find_template\fP (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred __pred, _Selector __selector, \fBgrowing_blocks_tag\fP)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector > \fBstd::pair\fP< _RAIter1, _RAIter2 > \fB__find_template\fP (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred __pred, _Selector __selector, \fBconstant_size_blocks_tag\fP)"
.br
.ti -1c
.RI "template<typename _IIter , typename _UserOp , typename _Functionality , typename _Red , typename _Result > _UserOp \fB__for_each_template_random_access\fP (_IIter __begin, _IIter __end, _UserOp __user_op, _Functionality &__functionality, _Red __reduction, _Result __reduction_start, _Result &__output, typename \fBstd::iterator_traits\fP< _IIter >::difference_type __bound, \fB_Parallelism\fP __parallelism_tag)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result > _Op \fB__for_each_template_random_access_ed\fP (_RAIter __begin, _RAIter __end, _Op __o, _Fu &__f, _Red __r, _Result __base, _Result &__output, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __bound)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result > _Op \fB__for_each_template_random_access_omp_loop\fP (_RAIter __begin, _RAIter __end, _Op __o, _Fu &__f, _Red __r, _Result __base, _Result &__output, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __bound)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result > _Op \fB__for_each_template_random_access_omp_loop_static\fP (_RAIter __begin, _RAIter __end, _Op __o, _Fu &__f, _Red __r, _Result __base, _Result &__output, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __bound)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result > _Op \fB__for_each_template_random_access_workstealing\fP (_RAIter __begin, _RAIter __end, _Op __op, _Fu &__f, _Red __r, _Result __base, _Result &__output, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __bound)"
.br
.ti -1c
.RI "\fB_ThreadIndex\fP \fB__get_max_threads\fP ()"
.br
.ti -1c
.RI "bool \fB__is_parallel\fP (const \fB_Parallelism\fP __p)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Compare > bool \fB__is_sorted\fP (_IIter __begin, _IIter __end, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > _RAIter \fB__median_of_three_iterators\fP (_RAIter __a, _RAIter __b, _RAIter __c, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp , typename _Compare > _OutputIterator \fB__merge_advance\fP (_RAIter1 &__begin1, _RAIter1 __end1, _RAIter2 &__begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp , typename _Compare > _OutputIterator \fB__merge_advance_movc\fP (_RAIter1 &__begin1, _RAIter1 __end1, _RAIter2 &__begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp , typename _Compare > _OutputIterator \fB__merge_advance_usual\fP (_RAIter1 &__begin1, _RAIter1 __end1, _RAIter2 &__begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter2 , typename _RAIter3 , typename _Compare > _RAIter3 \fB__parallel_merge_advance\fP (_RAIter1 &__begin1, _RAIter1 __end1, _RAIter2 &__begin2, _RAIter2 __end2, _RAIter3 __target, typename \fBstd::iterator_traits\fP< _RAIter1 >::difference_type __max_length, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter1 , typename _RAIter3 , typename _Compare > _RAIter3 \fB__parallel_merge_advance\fP (_RAIter1 &__begin1, _RAIter1 __end1, _RAIter1 &__begin2, _RAIter1 __end2, _RAIter3 __target, typename \fBstd::iterator_traits\fP< _RAIter1 >::difference_type __max_length, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fB__parallel_nth_element\fP (_RAIter __begin, _RAIter __nth, _RAIter __end, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fB__parallel_partial_sort\fP (_RAIter __begin, _RAIter __middle, _RAIter __end, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator , typename _BinaryOperation > _OutputIterator \fB__parallel_partial_sum\fP (_IIter __begin, _IIter __end, _OutputIterator __result, _BinaryOperation __bin_op)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator , typename _BinaryOperation > _OutputIterator \fB__parallel_partial_sum_basecase\fP (_IIter __begin, _IIter __end, _OutputIterator __result, _BinaryOperation __bin_op, typename \fBstd::iterator_traits\fP< _IIter >::value_type __value)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator , typename _BinaryOperation > _OutputIterator \fB__parallel_partial_sum_linear\fP (_IIter __begin, _IIter __end, _OutputIterator __result, _BinaryOperation __bin_op, typename \fBstd::iterator_traits\fP< _IIter >::difference_type __n)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Predicate > \fBstd::iterator_traits\fP< _RAIter >::difference_type \fB__parallel_partition\fP (_RAIter __begin, _RAIter __end, _Predicate __pred, \fB_ThreadIndex\fP __num_threads)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _RandomNumberGenerator > void \fB__parallel_random_shuffle\fP (_RAIter __begin, _RAIter __end, _RandomNumberGenerator __rng=\fB_RandomNumber\fP())"
.br
.ti -1c
.RI "template<typename _RAIter , typename _RandomNumberGenerator > void \fB__parallel_random_shuffle_drs\fP (_RAIter __begin, _RAIter __end, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __n, \fB_ThreadIndex\fP __num_threads, _RandomNumberGenerator &__rng)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _RandomNumberGenerator > void \fB__parallel_random_shuffle_drs_pu\fP (\fB_DRSSorterPU\fP< _RAIter, _RandomNumberGenerator > *__pus)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator , typename _Compare > _OutputIterator \fB__parallel_set_difference\fP (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator , typename _Compare > _OutputIterator \fB__parallel_set_intersection\fP (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator , typename Operation > _OutputIterator \fB__parallel_set_operation\fP (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2, _OutputIterator __result, Operation __op)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator , typename _Compare > _OutputIterator \fB__parallel_set_symmetric_difference\fP (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OutputIterator , typename _Compare > _OutputIterator \fB__parallel_set_union\fP (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIter , typename _Compare > void \fB__parallel_sort\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fBparallel_tag\fP __parallelism)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIter , typename _Compare > void \fB__parallel_sort\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fBbalanced_quicksort_tag\fP __parallelism)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIter , typename _Compare > void \fB__parallel_sort\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fBmultiway_mergesort_sampling_tag\fP __parallelism)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIter , typename _Compare , typename _Parallelism > void \fB__parallel_sort\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fB_Parallelism\fP __parallelism)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIter , typename _Compare > void \fB__parallel_sort\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fBmultiway_mergesort_tag\fP __parallelism)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIter , typename _Compare > void \fB__parallel_sort\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fBmultiway_mergesort_exact_tag\fP __parallelism)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIter , typename _Compare > void \fB__parallel_sort\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fBquicksort_tag\fP __parallelism)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIter , typename _Compare > void \fB__parallel_sort\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fBdefault_parallel_tag\fP __parallelism)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fB__parallel_sort_qs\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fB_ThreadIndex\fP __num_threads)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fB__parallel_sort_qs_conquer\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fB_ThreadIndex\fP __num_threads)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > \fBstd::iterator_traits\fP< _RAIter >::difference_type \fB__parallel_sort_qs_divide\fP (_RAIter __begin, _RAIter __end, _Compare __comp, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __pivot_rank, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __num_samples, \fB_ThreadIndex\fP __num_threads)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fB__parallel_sort_qsb\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fB_ThreadIndex\fP __num_threads)"
.br
.ti -1c
.RI "template<typename _IIter , class _OutputIterator > _OutputIterator \fB__parallel_unique_copy\fP (_IIter __first, _IIter __last, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _IIter , class _OutputIterator , class _BinaryPredicate > _OutputIterator \fB__parallel_unique_copy\fP (_IIter __first, _IIter __last, _OutputIterator __result, _BinaryPredicate __binary_pred)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fB__qsb_conquer\fP (\fB_QSBThreadLocal\fP< _RAIter > **__tls, _RAIter __begin, _RAIter __end, _Compare __comp, \fB_ThreadIndex\fP __iam, \fB_ThreadIndex\fP __num_threads, bool __parent_wait)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > \fBstd::iterator_traits\fP< _RAIter >::difference_type \fB__qsb_divide\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fB_ThreadIndex\fP __num_threads)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fB__qsb_local_sort_with_helping\fP (\fB_QSBThreadLocal\fP< _RAIter > **__tls, _Compare &__comp, \fB_ThreadIndex\fP __iam, bool __wait)"
.br
.ti -1c
.RI "template<typename _RandomNumberGenerator > int \fB__random_number_pow2\fP (int __logp, _RandomNumberGenerator &__rng)"
.br
.ti -1c
.RI "template<typename _Size > _Size \fB__rd_log2\fP (_Size __n)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fB__round_up_to_pow2\fP (_Tp __x)"
.br
.ti -1c
.RI "template<typename __RAIter1 , typename __RAIter2 , typename _Pred > __RAIter1 \fB__search_template\fP (__RAIter1 __begin1, __RAIter1 __end1, __RAIter2 __begin2, __RAIter2 __end2, _Pred __pred)"
.br
.ti -1c
.RI "template<bool __stable, bool __sentinels, typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 \fB__sequential_multiway_merge\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< _RAIterIterator >::value_type::first_type >::value_type &__sentinel, _DifferenceTp __length, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _RandomNumberGenerator > void \fB__sequential_random_shuffle\fP (_RAIter __begin, _RAIter __end, _RandomNumberGenerator &__rng)"
.br
.ti -1c
.RI "template<typename _IIter > void \fB__shrink\fP (\fBstd::vector\fP< _IIter > &__os_starts, size_t &__count_to_two, size_t &__range_length)"
.br
.ti -1c
.RI "template<typename _IIter > void \fB__shrink_and_double\fP (\fBstd::vector\fP< _IIter > &__os_starts, size_t &__count_to_two, size_t &__range_length, const bool __make_twice)"
.br
.ti -1c
.RI "void \fB__yield\fP ()"
.br
.ti -1c
.RI "template<typename _DifferenceType , typename _OutputIterator > _OutputIterator \fBequally_split\fP (_DifferenceType __n, \fB_ThreadIndex\fP __num_threads, _OutputIterator __s)"
.br
.ti -1c
.RI "template<typename _DifferenceType > _DifferenceType \fBequally_split_point\fP (_DifferenceType __n, \fB_ThreadIndex\fP __num_threads, \fB_ThreadIndex\fP __thread_no)"
.br
.ti -1c
.RI "template<typename _IIter , typename _FunctorType > size_t \fBlist_partition\fP (const _IIter __begin, const _IIter __end, _IIter *__starts, size_t *__lengths, const int __num_parts, _FunctorType &__f, int __oversampling=0)"
.br
.ti -1c
.RI "template<typename _Tp > const _Tp & \fBmax\fP (const _Tp &__a, const _Tp &__b)"
.br
.ti -1c
.RI "template<typename _Tp > const _Tp & \fBmin\fP (const _Tp &__a, const _Tp &__b)"
.br
.ti -1c
.RI "template<typename _RanSeqs , typename _RankType , typename _RankIterator , typename _Compare > void \fBmultiseq_partition\fP (_RanSeqs __begin_seqs, _RanSeqs __end_seqs, _RankType __rank, _RankIterator __begin_offsets, _Compare __comp=\fBstd::less\fP< typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< _RanSeqs >::value_type::first_type >::value_type >())"
.br
.ti -1c
.RI "template<typename _Tp , typename _RanSeqs , typename _RankType , typename _Compare > _Tp \fBmultiseq_selection\fP (_RanSeqs __begin_seqs, _RanSeqs __end_seqs, _RankType __rank, _RankType &__offset, _Compare __comp=\fBstd::less\fP< _Tp >())"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::sequential_tag\fP)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBdefault_parallel_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBparallel_tag\fP __tag=\fBparallel_tag\fP(0))"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::exact_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::sampling_tag\fP __tag)"
.br
.ti -1c
.RI "template<template< typename RAI, typename C > class iterator, typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 \fBmultiway_merge_3_variant\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _DifferenceTp __length, _Compare __comp)"
.br
.ti -1c
.RI "template<template< typename RAI, typename C > class iterator, typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 \fBmultiway_merge_4_variant\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _DifferenceTp __length, _Compare __comp)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIterIterator , typename _Compare , typename _DifferenceType > void \fBmultiway_merge_exact_splitting\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _DifferenceType __length, _DifferenceType __total_length, _Compare __comp, \fBstd::vector\fP< \fBstd::pair\fP< _DifferenceType, _DifferenceType > > *__pieces)"
.br
.ti -1c
.RI "template<typename _LT , typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 \fBmultiway_merge_loser_tree\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _DifferenceTp __length, _Compare __comp)"
.br
.ti -1c
.RI "template<typename UnguardedLoserTree , typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 \fBmultiway_merge_loser_tree_sentinel\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< _RAIterIterator >::value_type::first_type >::value_type &__sentinel, _DifferenceTp __length, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _LT , typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 \fBmultiway_merge_loser_tree_unguarded\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< _RAIterIterator >::value_type::first_type >::value_type &__sentinel, _DifferenceTp __length, _Compare __comp)"
.br
.ti -1c
.RI "template<bool __stable, typename _RAIterIterator , typename _Compare , typename _DifferenceType > void \fBmultiway_merge_sampling_splitting\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _DifferenceType __length, _DifferenceType __total_length, _Compare __comp, \fBstd::vector\fP< \fBstd::pair\fP< _DifferenceType, _DifferenceType > > *__pieces)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::sequential_tag\fP)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBparallel_tag\fP __tag=\fBparallel_tag\fP(0))"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::exact_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBdefault_parallel_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBmultiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBsampling_tag\fP __tag)"
.br
.ti -1c
.RI "template<bool __stable, bool __sentinels, typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Splitter , typename _Compare > _RAIter3 \fBparallel_multiway_merge\fP (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _Splitter __splitter, _DifferenceTp __length, _Compare __comp, \fB_ThreadIndex\fP __num_threads)"
.br
.ti -1c
.RI "template<bool __stable, bool __exact, typename _RAIter , typename _Compare > void \fBparallel_sort_mwms\fP (_RAIter __begin, _RAIter __end, _Compare __comp, \fB_ThreadIndex\fP __num_threads)"
.br
.ti -1c
.RI "template<bool __stable, bool __exact, typename _RAIter , typename _Compare > void \fBparallel_sort_mwms_pu\fP (\fB_PMWMSSortingData\fP< _RAIter > *__sd, _Compare &__comp)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBparallel_tag\fP __tag=\fBparallel_tag\fP(0))"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBsampling_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBdefault_parallel_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::sequential_tag\fP)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::exact_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::exact_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBdefault_parallel_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::sequential_tag\fP)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBsampling_tag\fP __tag)"
.br
.ti -1c
.RI "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut \fBstable_multiway_merge_sentinels\fP (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fBparallel_tag\fP __tag=\fBparallel_tag\fP(0))"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const int \fB_CASable_bits\fP"
.br
.ti -1c
.RI "static const \fB_CASable\fP \fB_CASable_mask\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
GNU parallel code for public use. 
.SH "Typedef Documentation"
.PP 
.SS "typedef unsigned short \fB__gnu_parallel::_BinIndex\fP"
.PP
Type to hold the index of a bin. Since many variables of this type are allocated, it should be chosen as small as possible. 
.PP
Definition at line 47 of file random_shuffle.h.
.SS "typedef int64_t \fB__gnu_parallel::_CASable\fP"
.PP
Longest compare-and-swappable integer type on this platform. 
.PP
Definition at line 127 of file types.h.
.SS "typedef uint64_t \fB__gnu_parallel::_SequenceIndex\fP"
.PP
Unsigned integer to index __elements. The total number of elements for each algorithm must fit into this type. 
.PP
Definition at line 117 of file types.h.
.SS "typedef uint16_t \fB__gnu_parallel::_ThreadIndex\fP"
.PP
Unsigned integer to index a thread number. The maximum thread number (for each processor) must fit into this type. 
.PP
Definition at line 123 of file types.h.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fB__gnu_parallel::_AlgorithmStrategy\fP"
.PP
Strategies for run-time algorithm selection: 
.PP
Definition at line 67 of file types.h.
.SS "enum \fB__gnu_parallel::_FindAlgorithm\fP"
.PP
Find algorithms: 
.PP
Definition at line 106 of file types.h.
.SS "enum \fB__gnu_parallel::_MultiwayMergeAlgorithm\fP"
.PP
Merging algorithms: 
.PP
Definition at line 85 of file types.h.
.SS "enum \fB__gnu_parallel::_Parallelism\fP"
.PP
Run-time equivalents for the compile-time tags. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIsequential \fP\fP
Not parallel. 
.TP
\fB\fIparallel_unbalanced \fP\fP
Parallel unbalanced (equal-sized chunks). 
.TP
\fB\fIparallel_balanced \fP\fP
Parallel balanced (work-stealing). 
.TP
\fB\fIparallel_omp_loop \fP\fP
Parallel with OpenMP dynamic load-balancing. 
.TP
\fB\fIparallel_omp_loop_static \fP\fP
Parallel with OpenMP static load-balancing. 
.TP
\fB\fIparallel_taskqueue \fP\fP
Parallel with OpenMP taskqueue construct. 
.PP
Definition at line 44 of file types.h.
.SS "enum \fB__gnu_parallel::_PartialSumAlgorithm\fP"
.PP
Partial sum algorithms: recursive, linear. 
.PP
Definition at line 91 of file types.h.
.SS "enum \fB__gnu_parallel::_SortAlgorithm\fP"
.PP
Sorting algorithms: 
.PP
Definition at line 76 of file types.h.
.SS "enum \fB__gnu_parallel::_SplittingAlgorithm\fP"
.PP
Sorting/merging algorithms: sampling, __exact. 
.PP
Definition at line 98 of file types.h.
.SH "Function Documentation"
.PP 
.SS "template<typename _RAIter , typename _DifferenceTp > void __gnu_parallel::__calc_borders (_RAIter __elements, _DifferenceTp __length, _DifferenceTp * __off)"
.PP
Precalculate __advances for Knuth-Morris-Pratt algorithm. \fBParameters:\fP
.RS 4
\fI__elements\fP Begin iterator of sequence to search for. 
.br
\fI__length\fP Length of sequence to search for. 
.br
\fI__advances\fP Returned __offsets. 
.RE
.PP

.PP
Definition at line 51 of file search.h.
.PP
Referenced by __search_template().
.SS "template<typename _Tp > bool __gnu_parallel::__compare_and_swap (volatile _Tp * __ptr, _Tp __comparand, _Tp __replacement)\fC [inline]\fP"
.PP
Compare \fC*__ptr\fP and \fC__comparand\fP. If equal, let \fC*__ptr=__replacement\fP and return \fCtrue\fP, return \fCfalse\fP otherwise. Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fI__ptr\fP Pointer to signed integer. 
.br
\fI__comparand\fP Compare value. 
.br
\fI__replacement\fP Replacement value. 
.RE
.PP

.PP
Definition at line 337 of file parallel/compatibility.h.
.PP
References __compare_and_swap_32(), and __compare_and_swap_64().
.PP
Referenced by __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::pop_back(), and __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::pop_front().
.SS "bool __gnu_parallel::__compare_and_swap_32 (volatile int32_t * __ptr, int32_t __comparand, int32_t __replacement)\fC [inline]\fP"
.PP
Compare \fC*__ptr\fP and \fC__comparand\fP. If equal, let \fC*__ptr=__replacement\fP and return \fCtrue\fP, return \fCfalse\fP otherwise. Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fI__ptr\fP Pointer to 32-bit signed integer. 
.br
\fI__comparand\fP Compare value. 
.br
\fI__replacement\fP Replacement value. 
.RE
.PP

.PP
Definition at line 240 of file parallel/compatibility.h.
.PP
Referenced by __compare_and_swap().
.SS "bool __gnu_parallel::__compare_and_swap_64 (volatile int64_t * __ptr, int64_t __comparand, int64_t __replacement)\fC [inline]\fP"
.PP
Compare \fC*__ptr\fP and \fC__comparand\fP. If equal, let \fC*__ptr=__replacement\fP and return \fCtrue\fP, return \fCfalse\fP otherwise. Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fI__ptr\fP Pointer to 64-bit signed integer. 
.br
\fI__comparand\fP Compare value. 
.br
\fI__replacement\fP Replacement value. 
.RE
.PP

.PP
Definition at line 283 of file parallel/compatibility.h.
.PP
Referenced by __compare_and_swap().
.SS "void __gnu_parallel::__decode2 (_CASable __x, int & __a, int & __b)\fC [inline]\fP"
.PP
Decode two integers from one gnu_parallel::_CASable. \fBParameters:\fP
.RS 4
\fI__x\fP \fB__gnu_parallel::_CASable\fP to decode integers from. 
.br
\fI__a\fP First integer, to be decoded from the most-significant \fC_CASable_bits/2\fP bits of \fC__x\fP. 
.br
\fI__b\fP Second integer, to be encoded in the least-significant \fC_CASable_bits/2\fP bits of \fC__x\fP. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fB__encode2\fP 
.RE
.PP

.PP
Definition at line 133 of file parallel/base.h.
.PP
References _CASable_bits, and _CASable_mask.
.PP
Referenced by __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::pop_back(), __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::pop_front(), and __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::push_front().
.SS "template<typename _RAIter , typename _DifferenceTp > void __gnu_parallel::__determine_samples (_PMWMSSortingData< _RAIter > * __sd, _DifferenceTp __num_samples)"
.PP
Select _M_samples from a sequence. \fBParameters:\fP
.RS 4
\fI__sd\fP Pointer to algorithm data. _Result will be placed in \fC__sd->_M_samples\fP. 
.br
\fI__num_samples\fP Number of _M_samples to select. 
.RE
.PP

.PP
Definition at line 97 of file multiway_mergesort.h.
.PP
References __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_samples, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_source, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_starts, and equally_split().
.SS "\fB_CASable\fP __gnu_parallel::__encode2 (int __a, int __b)\fC [inline]\fP"
.PP
Encode two integers into one gnu_parallel::_CASable. \fBParameters:\fP
.RS 4
\fI__a\fP First integer, to be encoded in the most-significant \fC_CASable_bits/2\fP bits. 
.br
\fI__b\fP Second integer, to be encoded in the least-significant \fC_CASable_bits/2\fP bits. 
.RE
.PP
\fBReturns:\fP
.RS 4
value encoding \fC__a\fP and \fC__b\fP. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fB__decode2\fP 
.RE
.PP

.PP
Definition at line 119 of file parallel/base.h.
.PP
References _CASable_bits.
.PP
Referenced by __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::_RestrictedBoundedConcurrentQueue(), __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::pop_back(), __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::pop_front(), and __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::push_front().
.SS "template<typename _Tp > _Tp __gnu_parallel::__fetch_and_add (volatile _Tp * __ptr, _Tp __addend)\fC [inline]\fP"
.PP
Add a value to a variable, atomically. Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fI__ptr\fP Pointer to a signed integer. 
.br
\fI__addend\fP Value to add. 
.RE
.PP

.PP
Definition at line 186 of file parallel/compatibility.h.
.PP
References __fetch_and_add_32(), and __fetch_and_add_64().
.PP
Referenced by __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Piece >::push_front().
.SS "int32_t __gnu_parallel::__fetch_and_add_32 (volatile int32_t * __ptr, int32_t __addend)\fC [inline]\fP"
.PP
Add a value to a variable, atomically. Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fI__ptr\fP Pointer to a 32-bit signed integer. 
.br
\fI__addend\fP Value to add. 
.RE
.PP

.PP
Definition at line 95 of file parallel/compatibility.h.
.PP
Referenced by __fetch_and_add().
.SS "int64_t __gnu_parallel::__fetch_and_add_64 (volatile int64_t * __ptr, int64_t __addend)\fC [inline]\fP"
.PP
Add a value to a variable, atomically. Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fI__ptr\fP Pointer to a 64-bit signed integer. 
.br
\fI__addend\fP Value to add. 
.RE
.PP

.PP
Definition at line 134 of file parallel/compatibility.h.
.PP
Referenced by __fetch_and_add().
.SS "template<typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector > \fBstd::pair\fP<_RAIter1, _RAIter2> __gnu_parallel::__find_template (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred __pred, _Selector __selector)\fC [inline]\fP"
.PP
Parallel std::find, switch for different algorithms. \fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. Must have same length as first sequence. 
.br
\fI__pred\fP Find predicate. 
.br
\fI__selector\fP _Functionality (e. g. std::find_if(), std::equal(),...) 
.RE
.PP
\fBReturns:\fP
.RS 4
Place of finding in both sequences. 
.RE
.PP

.PP
Definition at line 60 of file find.h.
.PP
References __gnu_parallel::_Settings::get().
.SS "template<typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector > \fBstd::pair\fP<_RAIter1, _RAIter2> __gnu_parallel::__find_template (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred __pred, _Selector __selector, equal_split_tag)"
.PP
Parallel std::find, equal splitting variant. \fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. Second __sequence must have same length as first sequence. 
.br
\fI__pred\fP Find predicate. 
.br
\fI__selector\fP _Functionality (e. g. std::find_if(), std::equal(),...) 
.RE
.PP
\fBReturns:\fP
.RS 4
Place of finding in both sequences. 
.RE
.PP

.PP
Definition at line 97 of file find.h.
.PP
References _GLIBCXX_CALL, and equally_split().
.SS "template<typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector > \fBstd::pair\fP<_RAIter1, _RAIter2> __gnu_parallel::__find_template (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred __pred, _Selector __selector, growing_blocks_tag)"
.PP
Parallel std::find, growing block size variant. \fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. Second __sequence must have same length as first sequence. 
.br
\fI__pred\fP Find predicate. 
.br
\fI__selector\fP _Functionality (e. g. std::find_if(), std::equal(),...) 
.RE
.PP
\fBReturns:\fP
.RS 4
Place of finding in both sequences. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fB__gnu_parallel::_Settings::find_sequential_search_size\fP 
.PP
\fB__gnu_parallel::_Settings::find_initial_block_size\fP 
.PP
\fB__gnu_parallel::_Settings::find_maximum_block_size\fP 
.PP
\fB__gnu_parallel::_Settings::find_increasing_factor\fP
.RE
.PP
There are two main differences between the growing blocks and the constant-size blocks variants. 1. For GB, the block size grows; for CSB, the block size is fixed. 2. For GB, the blocks are allocated dynamically; for CSB, the blocks are allocated in a predetermined manner, namely spacial round-robin. 
.PP
Definition at line 187 of file find.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_Settings::find_increasing_factor, __gnu_parallel::_Settings::find_initial_block_size, __gnu_parallel::_Settings::find_maximum_block_size, __gnu_parallel::_Settings::find_sequential_search_size, and __gnu_parallel::_Settings::get().
.SS "template<typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector > \fBstd::pair\fP<_RAIter1, _RAIter2> __gnu_parallel::__find_template (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred __pred, _Selector __selector, constant_size_blocks_tag)"
.PP
Parallel std::find, constant block size variant. \fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. Second __sequence must have same length as first sequence. 
.br
\fI__pred\fP Find predicate. 
.br
\fI__selector\fP _Functionality (e. g. std::find_if(), std::equal(),...) 
.RE
.PP
\fBReturns:\fP
.RS 4
Place of finding in both sequences. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fB__gnu_parallel::_Settings::find_sequential_search_size\fP 
.PP
__gnu_parallel::_Settings::find_block_size There are two main differences between the growing blocks and the constant-size blocks variants. 1. For GB, the block size grows; for CSB, the block size is fixed. 2. For GB, the blocks are allocated dynamically; for CSB, the blocks are allocated in a predetermined manner, namely spacial round-robin. 
.RE
.PP

.PP
Definition at line 315 of file find.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_Settings::find_initial_block_size, __gnu_parallel::_Settings::find_sequential_search_size, and __gnu_parallel::_Settings::get().
.SS "template<typename _IIter , typename _UserOp , typename _Functionality , typename _Red , typename _Result > _UserOp __gnu_parallel::__for_each_template_random_access (_IIter __begin, _IIter __end, _UserOp __user_op, _Functionality & __functionality, _Red __reduction, _Result __reduction_start, _Result & __output, typename \fBstd::iterator_traits\fP< _IIter >::difference_type __bound, _Parallelism __parallelism_tag)"
.PP
Chose the desired algorithm by evaluating \fC__parallelism_tag\fP. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__user_op\fP A user-specified functor (comparator, predicate, associative operator,...) 
.br
\fI__functionality\fP functor to \fIprocess\fP an element with __user_op (depends on desired functionality, e. g. accumulate, for_each,... 
.br
\fI__reduction\fP Reduction functor. 
.br
\fI__reduction_start\fP Initial value for reduction. 
.br
\fI__output\fP Output iterator. 
.br
\fI__bound\fP Maximum number of elements processed. 
.br
\fI__parallelism_tag\fP Parallelization method 
.RE
.PP

.PP
Definition at line 61 of file for_each.h.
.PP
References __for_each_template_random_access_ed(), __for_each_template_random_access_omp_loop(), __for_each_template_random_access_workstealing(), parallel_omp_loop, parallel_omp_loop_static, and parallel_unbalanced.
.SS "template<typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result > _Op __gnu_parallel::__for_each_template_random_access_ed (_RAIter __begin, _RAIter __end, _Op __o, _Fu & __f, _Red __r, _Result __base, _Result & __output, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __bound)"
.PP
Embarrassingly parallel algorithm for random access iterators, using hand-crafted parallelization by equal splitting the work. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of element sequence. 
.br
\fI__end\fP End iterator of element sequence. 
.br
\fI__o\fP User-supplied functor (comparator, predicate, adding functor, ...) 
.br
\fI__f\fP Functor to 'process' an element with __op (depends on desired functionality, e. g. for std::for_each(), ...). 
.br
\fI__r\fP Functor to 'add' a single __result to the already processed elements (depends on functionality). 
.br
\fI__base\fP Base value for reduction. 
.br
\fI__output\fP Pointer to position where final result is written to 
.br
\fI__bound\fP Maximum number of elements processed (e. g. for std::count_n()). 
.RE
.PP
\fBReturns:\fP
.RS 4
User-supplied functor (that may contain a part of the result). 
.RE
.PP

.PP
Definition at line 67 of file par_loop.h.
.PP
References equally_split_point().
.PP
Referenced by __for_each_template_random_access().
.SS "template<typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result > _Op __gnu_parallel::__for_each_template_random_access_omp_loop (_RAIter __begin, _RAIter __end, _Op __o, _Fu & __f, _Red __r, _Result __base, _Result & __output, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __bound)"
.PP
Embarrassingly parallel algorithm for random access iterators, using an OpenMP for loop. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of element sequence. 
.br
\fI__end\fP End iterator of element sequence. 
.br
\fI__o\fP User-supplied functor (comparator, predicate, adding functor, etc.). 
.br
\fI__f\fP Functor to \fIprocess\fP an element with __op (depends on desired functionality, e. g. for std::for_each(), ...). 
.br
\fI__r\fP Functor to \fIadd\fP a single __result to the already processed elements (depends on functionality). 
.br
\fI__base\fP Base value for reduction. 
.br
\fI__output\fP Pointer to position where final result is written to 
.br
\fI__bound\fP Maximum number of elements processed (e. g. for std::count_n()). 
.RE
.PP
\fBReturns:\fP
.RS 4
User-supplied functor (that may contain a part of the result). 
.RE
.PP

.PP
Definition at line 67 of file omp_loop.h.
.PP
Referenced by __for_each_template_random_access().
.SS "template<typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result > _Op __gnu_parallel::__for_each_template_random_access_omp_loop_static (_RAIter __begin, _RAIter __end, _Op __o, _Fu & __f, _Red __r, _Result __base, _Result & __output, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __bound)"
.PP
Embarrassingly parallel algorithm for random access iterators, using an OpenMP for loop with static scheduling. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of element sequence. 
.br
\fI__end\fP End iterator of element sequence. 
.br
\fI__o\fP User-supplied functor (comparator, predicate, adding functor, ...). 
.br
\fI__f\fP Functor to \fIprocess\fP an element with __op (depends on desired functionality, e. g. for std::for_each(), ...). 
.br
\fI__r\fP Functor to \fIadd\fP a single __result to the already processed __elements (depends on functionality). 
.br
\fI__base\fP Base value for reduction. 
.br
\fI__output\fP Pointer to position where final result is written to 
.br
\fI__bound\fP Maximum number of elements processed (e. g. for std::count_n()). 
.RE
.PP
\fBReturns:\fP
.RS 4
User-supplied functor (that may contain a part of the result). 
.RE
.PP

.PP
Definition at line 66 of file omp_loop_static.h.
.SS "template<typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result > _Op __gnu_parallel::__for_each_template_random_access_workstealing (_RAIter __begin, _RAIter __end, _Op __op, _Fu & __f, _Red __r, _Result __base, _Result & __output, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __bound)"
.PP
Work stealing algorithm for random access iterators. Uses O(1) additional memory. Synchronization at job lists is done with atomic operations. 
.PP
\fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of element sequence. 
.br
\fI__end\fP End iterator of element sequence. 
.br
\fI__op\fP User-supplied functor (comparator, predicate, adding functor, ...). 
.br
\fI__f\fP Functor to \fIprocess\fP an element with __op (depends on desired functionality, e. g. for std::for_each(), ...). 
.br
\fI__r\fP Functor to \fIadd\fP a single __result to the already processed elements (depends on functionality). 
.br
\fI__base\fP Base value for reduction. 
.br
\fI__output\fP Pointer to position where final result is written to 
.br
\fI__bound\fP Maximum number of elements processed (e. g. for std::count_n()). 
.RE
.PP
\fBReturns:\fP
.RS 4
User-supplied functor (that may contain a part of the result). 
.RE
.PP

.PP
Definition at line 99 of file workstealing.h.
.PP
References __yield(), _GLIBCXX_CALL, __gnu_parallel::_Job< _DifferenceTp >::_M_first, __gnu_parallel::_Job< _DifferenceTp >::_M_last, __gnu_parallel::_Job< _DifferenceTp >::_M_load, __gnu_parallel::_Settings::cache_line_size, __gnu_parallel::_Settings::get(), and min().
.PP
Referenced by __for_each_template_random_access().
.SS "template<typename _IIter , typename _Compare > bool __gnu_parallel::__is_sorted (_IIter __begin, _IIter __end, _Compare __comp)"
.PP
Check whether \fC\fP[__begin, \fC__end\fP) is sorted according to \fC__comp\fP. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of sequence. 
.br
\fI__end\fP End iterator of sequence. 
.br
\fI__comp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if sorted, \fCfalse\fP otherwise. 
.RE
.PP

.PP
Definition at line 51 of file checkers.h.
.PP
Referenced by __sequential_multiway_merge(), multiway_merge_loser_tree_sentinel(), and parallel_multiway_merge().
.SS "template<typename _RAIter , typename _Compare > _RAIter __gnu_parallel::__median_of_three_iterators (_RAIter __a, _RAIter __b, _RAIter __c, _Compare __comp)"
.PP
Compute the median of three referenced elements, according to \fC__comp\fP. \fBParameters:\fP
.RS 4
\fI__a\fP First iterator. 
.br
\fI__b\fP Second iterator. 
.br
\fI__c\fP Third iterator. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 398 of file parallel/base.h.
.PP
Referenced by __qsb_divide().
.SS "template<typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp , typename _Compare > _OutputIterator __gnu_parallel::__merge_advance (_RAIter1 & __begin1, _RAIter1 __end1, _RAIter2 & __begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare __comp)\fC [inline]\fP"
.PP
Merge routine being able to merge only the \fC__max_length\fP smallest elements. The \fC__begin\fP iterators are advanced accordingly, they might not reach \fC__end\fP, in contrast to the usual variant. Static switch on whether to use the conditional-move variant. 
.PP
\fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. 
.br
\fI__end2\fP End iterator of second sequence. 
.br
\fI__target\fP Target begin iterator. 
.br
\fI__max_length\fP Maximum number of elements to merge. 
.br
\fI__comp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 171 of file merge.h.
.PP
References __merge_advance_movc(), and _GLIBCXX_CALL.
.PP
Referenced by __parallel_merge_advance(), and __sequential_multiway_merge().
.SS "template<typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp , typename _Compare > _OutputIterator __gnu_parallel::__merge_advance_movc (_RAIter1 & __begin1, _RAIter1 __end1, _RAIter2 & __begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare __comp)"
.PP
Merge routine being able to merge only the \fC__max_length\fP smallest elements. The \fC__begin\fP iterators are advanced accordingly, they might not reach \fC__end\fP, in contrast to the usual variant. Specially designed code should allow the compiler to generate conditional moves instead of branches. 
.PP
\fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. 
.br
\fI__end2\fP End iterator of second sequence. 
.br
\fI__target\fP Target begin iterator. 
.br
\fI__max_length\fP Maximum number of elements to merge. 
.br
\fI__comp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 105 of file merge.h.
.PP
Referenced by __merge_advance().
.SS "template<typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp , typename _Compare > _OutputIterator __gnu_parallel::__merge_advance_usual (_RAIter1 & __begin1, _RAIter1 __end1, _RAIter2 & __begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare __comp)"
.PP
Merge routine being able to merge only the \fC__max_length\fP smallest elements. The \fC__begin\fP iterators are advanced accordingly, they might not reach \fC__end\fP, in contrast to the usual variant. 
.PP
\fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. 
.br
\fI__end2\fP End iterator of second sequence. 
.br
\fI__target\fP Target begin iterator. 
.br
\fI__max_length\fP Maximum number of elements to merge. 
.br
\fI__comp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 57 of file merge.h.
.SS "template<typename _RAIter1 , typename _RAIter2 , typename _RAIter3 , typename _Compare > _RAIter3 __gnu_parallel::__parallel_merge_advance (_RAIter1 & __begin1, _RAIter1 __end1, _RAIter2 & __begin2, _RAIter2 __end2, _RAIter3 __target, typename \fBstd::iterator_traits\fP< _RAIter1 >::difference_type __max_length, _Compare __comp)\fC [inline]\fP"
.PP
Merge routine fallback to sequential in case the iterators of the two input sequences are of different type. \fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. 
.br
\fI__end2\fP End iterator of second sequence. 
.br
\fI__target\fP Target begin iterator. 
.br
\fI__max_length\fP Maximum number of elements to merge. 
.br
\fI__comp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 195 of file merge.h.
.PP
References __merge_advance().
.SS "template<typename _RAIter1 , typename _RAIter3 , typename _Compare > _RAIter3 __gnu_parallel::__parallel_merge_advance (_RAIter1 & __begin1, _RAIter1 __end1, _RAIter1 & __begin2, _RAIter1 __end2, _RAIter3 __target, typename \fBstd::iterator_traits\fP< _RAIter1 >::difference_type __max_length, _Compare __comp)\fC [inline]\fP"
.PP
Parallel merge routine being able to merge only the \fC__max_length\fP smallest elements. The \fC__begin\fP iterators are advanced accordingly, they might not reach \fC__end\fP, in contrast to the usual variant. The functionality is projected onto parallel_multiway_merge. 
.PP
\fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. 
.br
\fI__end2\fP End iterator of second sequence. 
.br
\fI__target\fP Target begin iterator. 
.br
\fI__max_length\fP Maximum number of elements to merge. 
.br
\fI__comp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 223 of file merge.h.
.PP
References multiway_merge_exact_splitting(), and parallel_multiway_merge().
.SS "template<typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_nth_element (_RAIter __begin, _RAIter __nth, _RAIter __end, _Compare __comp)"
.PP
Parallel implementation of std::nth_element(). \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__nth\fP _Iterator of element that must be in position afterwards. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 336 of file partition.h.
.PP
References __parallel_partition(), _GLIBCXX_CALL, __gnu_parallel::_Settings::get(), max(), __gnu_parallel::_Settings::nth_element_minimal_n, __gnu_parallel::_Settings::partition_minimal_n, and std::swap().
.PP
Referenced by __parallel_partial_sort().
.SS "template<typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_partial_sort (_RAIter __begin, _RAIter __middle, _RAIter __end, _Compare __comp)"
.PP
Parallel implementation of std::partial_sort(). \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__middle\fP Sort until this position. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 426 of file partition.h.
.PP
References __parallel_nth_element().
.SS "template<typename _IIter , typename _OutputIterator , typename _BinaryOperation > _OutputIterator __gnu_parallel::__parallel_partial_sum (_IIter __begin, _IIter __end, _OutputIterator __result, _BinaryOperation __bin_op)"
.PP
Parallel partial sum front-__end. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__result\fP Begin iterator of output sequence. 
.br
\fI__bin_op\fP Associative binary function. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 200 of file partial_sum.h.
.PP
References __parallel_partial_sum_linear(), _GLIBCXX_CALL, and __gnu_parallel::_Settings::get().
.SS "template<typename _IIter , typename _OutputIterator , typename _BinaryOperation > _OutputIterator __gnu_parallel::__parallel_partial_sum_basecase (_IIter __begin, _IIter __end, _OutputIterator __result, _BinaryOperation __bin_op, typename \fBstd::iterator_traits\fP< _IIter >::value_type __value)"
.PP
Base case prefix sum routine. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__result\fP Begin iterator of output sequence. 
.br
\fI__bin_op\fP Associative binary function. 
.br
\fI__value\fP Start value. Must be passed since the neutral element is unknown in general. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 58 of file partial_sum.h.
.PP
Referenced by __parallel_partial_sum_linear().
.SS "template<typename _IIter , typename _OutputIterator , typename _BinaryOperation > _OutputIterator __gnu_parallel::__parallel_partial_sum_linear (_IIter __begin, _IIter __end, _OutputIterator __result, _BinaryOperation __bin_op, typename \fBstd::iterator_traits\fP< _IIter >::difference_type __n)"
.PP
Parallel partial sum implementation, two-phase approach, no recursion. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__result\fP Begin iterator of output sequence. 
.br
\fI__bin_op\fP Associative binary function. 
.br
\fI__n\fP Length of sequence. 
.br
\fI__num_threads\fP Number of threads to use. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 90 of file partial_sum.h.
.PP
References __parallel_partial_sum_basecase(), equally_split(), __gnu_parallel::_Settings::get(), and __gnu_parallel::_Settings::partial_sum_dilation.
.PP
Referenced by __parallel_partial_sum().
.SS "template<typename _RAIter , typename _Predicate > \fBstd::iterator_traits\fP<_RAIter>::difference_type __gnu_parallel::__parallel_partition (_RAIter __begin, _RAIter __end, _Predicate __pred, _ThreadIndex __num_threads)"
.PP
Parallel implementation of std::partition. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence to split. 
.br
\fI__end\fP End iterator of input sequence to split. 
.br
\fI__pred\fP Partition predicate, possibly including some kind of pivot. 
.br
\fI__num_threads\fP Maximum number of threads to use for this task. 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of elements not fulfilling the predicate. 
.RE
.PP

.PP
Definition at line 56 of file partition.h.
.PP
References _GLIBCXX_CALL, _GLIBCXX_VOLATILE, __gnu_parallel::_Settings::get(), __gnu_parallel::_Settings::partition_chunk_share, __gnu_parallel::_Settings::partition_chunk_size, and std::swap().
.PP
Referenced by __parallel_nth_element(), __parallel_sort_qs_divide(), and __qsb_divide().
.SS "template<typename _RAIter , typename _RandomNumberGenerator > void __gnu_parallel::__parallel_random_shuffle (_RAIter __begin, _RAIter __end, _RandomNumberGenerator __rng = \fC_RandomNumber()\fP)\fC [inline]\fP"
.PP
Parallel random public call. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of sequence. 
.br
\fI__end\fP End iterator of sequence. 
.br
\fI__rng\fP Random number generator to use. 
.RE
.PP

.PP
Definition at line 517 of file random_shuffle.h.
.PP
References __parallel_random_shuffle_drs().
.SS "template<typename _RAIter , typename _RandomNumberGenerator > void __gnu_parallel::__parallel_random_shuffle_drs (_RAIter __begin, _RAIter __end, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __n, _ThreadIndex __num_threads, _RandomNumberGenerator & __rng)"
.PP
Main parallel random shuffle step. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of sequence. 
.br
\fI__end\fP End iterator of sequence. 
.br
\fI__n\fP Length of sequence. 
.br
\fI__num_threads\fP Number of threads to use. 
.br
\fI__rng\fP Random number generator to use. 
.RE
.PP

.PP
Definition at line 263 of file random_shuffle.h.
.PP
References __gnu_parallel::_DRSSorterPU< _RAIter, _RandomNumberGenerator >::__bins_end, __parallel_random_shuffle_drs_pu(), __rd_log2(), __round_up_to_pow2(), __sequential_random_shuffle(), _GLIBCXX_CALL, __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_bin_proc, __gnu_parallel::_DRSSorterPU< _RAIter, _RandomNumberGenerator >::_M_bins_begin, __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_dist, __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_num_bins, __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_num_bits, __gnu_parallel::_DRSSorterPU< _RAIter, _RandomNumberGenerator >::_M_num_threads, __gnu_parallel::_DRSSorterPU< _RAIter, _RandomNumberGenerator >::_M_sd, __gnu_parallel::_DRSSorterPU< _RAIter, _RandomNumberGenerator >::_M_seed, __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_starts, __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_temporaries, __gnu_parallel::_Settings::L2_cache_size, std::min(), and __gnu_parallel::_Settings::TLB_size.
.PP
Referenced by __parallel_random_shuffle().
.SS "template<typename _RAIter , typename _RandomNumberGenerator > void __gnu_parallel::__parallel_random_shuffle_drs_pu (_DRSSorterPU< _RAIter, _RandomNumberGenerator > * __pus)"
.PP
Random shuffle code executed by each thread. \fBParameters:\fP
.RS 4
\fI__pus\fP Array of thread-local data records. 
.RE
.PP

.PP
Definition at line 122 of file random_shuffle.h.
.PP
References __random_number_pow2(), __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_dist, __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_num_bins, __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_num_bits, __gnu_parallel::_DRSSorterPU< _RAIter, _RandomNumberGenerator >::_M_num_threads, __gnu_parallel::_DRSSorterPU< _RAIter, _RandomNumberGenerator >::_M_sd, __gnu_parallel::_DRSSorterPU< _RAIter, _RandomNumberGenerator >::_M_seed, and __gnu_parallel::_DRandomShufflingGlobalData< _RAIter >::_M_starts.
.PP
Referenced by __parallel_random_shuffle_drs().
.SS "template<bool __stable, typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort (_RAIter __begin, _RAIter __end, _Compare __comp, parallel_tag __parallelism)\fC [inline]\fP"
.PP
Choose a parallel sorting algorithm. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__stable\fP Sort __stable. 
.RE
.PP

.PP
Definition at line 198 of file sort.h.
.PP
References __gnu_parallel::parallel_tag::__get_num_threads(), __parallel_sort_qs(), __parallel_sort_qsb(), _GLIBCXX_CALL, and __gnu_parallel::_Settings::get().
.SS "template<bool __stable, typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort (_RAIter __begin, _RAIter __end, _Compare __comp, balanced_quicksort_tag __parallelism)\fC [inline]\fP"
.PP
Choose balanced quicksort for parallel sorting. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__stable\fP Sort __stable. 
.RE
.PP

.PP
Definition at line 157 of file sort.h.
.PP
References __gnu_parallel::parallel_tag::__get_num_threads(), __parallel_sort_qsb(), and _GLIBCXX_CALL.
.SS "template<bool __stable, typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort (_RAIter __begin, _RAIter __end, _Compare __comp, multiway_mergesort_sampling_tag __parallelism)\fC [inline]\fP"
.PP
Choose multiway mergesort with splitting by sampling, for parallel sorting. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 117 of file sort.h.
.PP
References __gnu_parallel::parallel_tag::__get_num_threads(), and _GLIBCXX_CALL.
.SS "template<bool __stable, typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort (_RAIter __begin, _RAIter __end, _Compare __comp, multiway_mergesort_tag __parallelism)\fC [inline]\fP"
.PP
Choose multiway mergesort, splitting variant at run-time, for parallel sorting. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 74 of file sort.h.
.PP
References __gnu_parallel::parallel_tag::__get_num_threads(), _GLIBCXX_CALL, and __gnu_parallel::_Settings::get().
.SS "template<bool __stable, typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort (_RAIter __begin, _RAIter __end, _Compare __comp, multiway_mergesort_exact_tag __parallelism)\fC [inline]\fP"
.PP
Choose multiway mergesort with exact splitting, for parallel sorting. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 97 of file sort.h.
.PP
References __gnu_parallel::parallel_tag::__get_num_threads(), and _GLIBCXX_CALL.
.SS "template<bool __stable, typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort (_RAIter __begin, _RAIter __end, _Compare __comp, quicksort_tag __parallelism)\fC [inline]\fP"
.PP
Choose quicksort for parallel sorting. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 136 of file sort.h.
.PP
References __gnu_parallel::parallel_tag::__get_num_threads(), __parallel_sort_qs(), and _GLIBCXX_CALL.
.SS "template<bool __stable, typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort (_RAIter __begin, _RAIter __end, _Compare __comp, default_parallel_tag __parallelism)\fC [inline]\fP"
.PP
Choose multiway mergesort with exact splitting, for parallel sorting. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 178 of file sort.h.
.PP
References __gnu_parallel::parallel_tag::__get_num_threads(), and _GLIBCXX_CALL.
.SS "template<typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort_qs (_RAIter __begin, _RAIter __end, _Compare __comp, _ThreadIndex __num_threads)"
.PP
Unbalanced quicksort main call. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator input sequence, ignored. 
.br
\fI__comp\fP Comparator. 
.br
\fI__num_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 152 of file quicksort.h.
.PP
References __parallel_sort_qs_conquer(), and _GLIBCXX_CALL.
.PP
Referenced by __parallel_sort().
.SS "template<typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort_qs_conquer (_RAIter __begin, _RAIter __end, _Compare __comp, _ThreadIndex __num_threads)"
.PP
Unbalanced quicksort conquer step. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of subsequence. 
.br
\fI__end\fP End iterator of subsequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__num_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 99 of file quicksort.h.
.PP
References __parallel_sort_qs_divide(), and __gnu_parallel::_Settings::get().
.PP
Referenced by __parallel_sort_qs().
.SS "template<typename _RAIter , typename _Compare > \fBstd::iterator_traits\fP<_RAIter>::difference_type __gnu_parallel::__parallel_sort_qs_divide (_RAIter __begin, _RAIter __end, _Compare __comp, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __pivot_rank, typename \fBstd::iterator_traits\fP< _RAIter >::difference_type __num_samples, _ThreadIndex __num_threads)"
.PP
Unbalanced quicksort divide step. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of subsequence. 
.br
\fI__end\fP End iterator of subsequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__pivot_rank\fP Desired __rank of the pivot. 
.br
\fI__num_samples\fP Choose pivot from that many samples. 
.br
\fI__num_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 51 of file quicksort.h.
.PP
References __parallel_partition(), and min().
.PP
Referenced by __parallel_sort_qs_conquer().
.SS "template<typename _RAIter , typename _Compare > void __gnu_parallel::__parallel_sort_qsb (_RAIter __begin, _RAIter __end, _Compare __comp, _ThreadIndex __num_threads)"
.PP
Top-level quicksort routine. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of sequence. 
.br
\fI__end\fP End iterator of sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__num_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 430 of file balanced_quicksort.h.
.PP
References __qsb_conquer(), __rd_log2(), and _GLIBCXX_CALL.
.PP
Referenced by __parallel_sort().
.SS "template<typename _IIter , class _OutputIterator > _OutputIterator __gnu_parallel::__parallel_unique_copy (_IIter __first, _IIter __last, _OutputIterator __result)\fC [inline]\fP"
.PP
Parallel std::unique_copy(), without explicit equality predicate. \fBParameters:\fP
.RS 4
\fI__first\fP Begin iterator of input sequence. 
.br
\fI__last\fP End iterator of input sequence. 
.br
\fI__result\fP Begin iterator of result __sequence. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of result __sequence. 
.RE
.PP

.PP
Definition at line 186 of file unique_copy.h.
.PP
References __parallel_unique_copy().
.SS "template<typename _IIter , class _OutputIterator , class _BinaryPredicate > _OutputIterator __gnu_parallel::__parallel_unique_copy (_IIter __first, _IIter __last, _OutputIterator __result, _BinaryPredicate __binary_pred)"
.PP
Parallel std::unique_copy(), w/__o explicit equality predicate. \fBParameters:\fP
.RS 4
\fI__first\fP Begin iterator of input sequence. 
.br
\fI__last\fP End iterator of input sequence. 
.br
\fI__result\fP Begin iterator of result __sequence. 
.br
\fI__binary_pred\fP Equality predicate. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of result __sequence. 
.RE
.PP

.PP
Definition at line 50 of file unique_copy.h.
.PP
References _GLIBCXX_CALL, and equally_split().
.PP
Referenced by __parallel_unique_copy().
.SS "template<typename _RAIter , typename _Compare > void __gnu_parallel::__qsb_conquer (_QSBThreadLocal< _RAIter > ** __tls, _RAIter __begin, _RAIter __end, _Compare __comp, _ThreadIndex __iam, _ThreadIndex __num_threads, bool __parent_wait)"
.PP
Quicksort conquer step. \fBParameters:\fP
.RS 4
\fI__tls\fP Array of thread-local storages. 
.br
\fI__begin\fP Begin iterator of subsequence. 
.br
\fI__end\fP End iterator of subsequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__iam\fP Number of the thread processing this function. 
.br
\fI__num_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 171 of file balanced_quicksort.h.
.PP
References __qsb_divide(), __qsb_local_sort_with_helping(), __gnu_parallel::_QSBThreadLocal< _RAIter >::_M_elements_leftover, and __gnu_parallel::_QSBThreadLocal< _RAIter >::_M_initial.
.PP
Referenced by __parallel_sort_qsb().
.SS "template<typename _RAIter , typename _Compare > \fBstd::iterator_traits\fP<_RAIter>::difference_type __gnu_parallel::__qsb_divide (_RAIter __begin, _RAIter __end, _Compare __comp, _ThreadIndex __num_threads)"
.PP
Balanced quicksort divide step. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of subsequence. 
.br
\fI__end\fP End iterator of subsequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__num_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fC\fP(__end-__begin)>=1 
.RE
.PP

.PP
Definition at line 100 of file balanced_quicksort.h.
.PP
References __median_of_three_iterators(), __parallel_partition(), and std::swap().
.PP
Referenced by __qsb_conquer().
.SS "template<typename _RAIter , typename _Compare > void __gnu_parallel::__qsb_local_sort_with_helping (_QSBThreadLocal< _RAIter > ** __tls, _Compare & __comp, _ThreadIndex __iam, bool __wait)"
.PP
Quicksort step doing load-balanced local sort. \fBParameters:\fP
.RS 4
\fI__tls\fP Array of thread-local storages. 
.br
\fI__comp\fP Comparator. 
.br
\fI__iam\fP Number of the thread processing this function. 
.RE
.PP

.PP
Definition at line 247 of file balanced_quicksort.h.
.PP
References __yield(), _GLIBCXX_ASSERTIONS, __gnu_parallel::_QSBThreadLocal< _RAIter >::_M_elements_leftover, __gnu_parallel::_QSBThreadLocal< _RAIter >::_M_initial, __gnu_parallel::_QSBThreadLocal< _RAIter >::_M_leftover_parts, __gnu_parallel::_QSBThreadLocal< _RAIter >::_M_num_threads, __gnu_parallel::_Settings::get(), __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Tp >::pop_front(), __gnu_parallel::_RestrictedBoundedConcurrentQueue< _Tp >::push_front(), __gnu_parallel::_Settings::sort_qsb_base_case_maximal_n, and std::swap().
.PP
Referenced by __qsb_conquer().
.SS "template<typename _RandomNumberGenerator > int __gnu_parallel::__random_number_pow2 (int __logp, _RandomNumberGenerator & __rng)\fC [inline]\fP"
.PP
Generate a random number in \fC\fP[0,2^__logp). \fBParameters:\fP
.RS 4
\fI__logp\fP Logarithm (basis 2) of the upper range __bound. 
.br
\fI__rng\fP Random number generator to use. 
.RE
.PP

.PP
Definition at line 115 of file random_shuffle.h.
.PP
Referenced by __parallel_random_shuffle_drs_pu(), and __sequential_random_shuffle().
.SS "template<typename _Size > _Size __gnu_parallel::__rd_log2 (_Size __n)\fC [inline]\fP"
.PP
Calculates the rounded-down logarithm of \fC__n\fP for base 2. \fBParameters:\fP
.RS 4
\fI__n\fP Argument. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns 0 for any argument <1. 
.RE
.PP

.PP
Definition at line 102 of file parallel/base.h.
.PP
Referenced by __parallel_random_shuffle_drs(), __parallel_sort_qsb(), __round_up_to_pow2(), __sequential_random_shuffle(), __gnu_parallel::_LoserTreeBase< _Tp, _Compare >::_LoserTreeBase(), multiseq_partition(), and multiseq_selection().
.SS "template<typename _Tp > _Tp __gnu_parallel::__round_up_to_pow2 (_Tp __x)"
.PP
Round up to the next greater power of 2. \fBParameters:\fP
.RS 4
\fI__x\fP _Integer to round up 
.RE
.PP

.PP
Definition at line 246 of file random_shuffle.h.
.PP
References __rd_log2().
.PP
Referenced by __parallel_random_shuffle_drs(), __sequential_random_shuffle(), and multiseq_selection().
.SS "template<typename __RAIter1 , typename __RAIter2 , typename _Pred > __RAIter1 __gnu_parallel::__search_template (__RAIter1 __begin1, __RAIter1 __end1, __RAIter2 __begin2, __RAIter2 __end2, _Pred __pred)"
.PP
Parallel std::search. \fBParameters:\fP
.RS 4
\fI__begin1\fP Begin iterator of first sequence. 
.br
\fI__end1\fP End iterator of first sequence. 
.br
\fI__begin2\fP Begin iterator of second sequence. 
.br
\fI__end2\fP End iterator of second sequence. 
.br
\fI__pred\fP Find predicate. 
.RE
.PP
\fBReturns:\fP
.RS 4
Place of finding in first sequences. 
.RE
.PP

.PP
Definition at line 81 of file search.h.
.PP
References __calc_borders(), _GLIBCXX_CALL, equally_split(), and min().
.SS "template<bool __stable, bool __sentinels, typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 __gnu_parallel::__sequential_multiway_merge (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< _RAIterIterator >::value_type::first_type >::value_type & __sentinel, _DifferenceTp __length, _Compare __comp)"
.PP
Sequential multi-way merging switch. The _GLIBCXX_PARALLEL_DECISION is based on the branching factor and runtime settings. 
.PP
\fBParameters:\fP
.RS 4
\fI__seqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fI__seqs_end\fP End iterator of iterator pair input sequence. 
.br
\fI__target\fP Begin iterator of output sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__length\fP Maximum length to merge, possibly larger than the number of elements available. 
.br
\fI__stable\fP Stable merging incurs a performance penalty. 
.br
\fI__sentinel\fP The sequences have __a __sentinel element. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 917 of file multiway_merge.h.
.PP
References __is_sorted(), __merge_advance(), _GLIBCXX_CALL, and _GLIBCXX_PARALLEL_LENGTH.
.PP
Referenced by multiway_merge(), and multiway_merge_sentinels().
.SS "template<typename _RAIter , typename _RandomNumberGenerator > void __gnu_parallel::__sequential_random_shuffle (_RAIter __begin, _RAIter __end, _RandomNumberGenerator & __rng)"
.PP
Sequential cache-efficient random shuffle. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of sequence. 
.br
\fI__end\fP End iterator of sequence. 
.br
\fI__rng\fP Random number generator to use. 
.RE
.PP

.PP
Definition at line 408 of file random_shuffle.h.
.PP
References __random_number_pow2(), __rd_log2(), __round_up_to_pow2(), __gnu_parallel::_Settings::L2_cache_size, std::min(), and __gnu_parallel::_Settings::TLB_size.
.PP
Referenced by __parallel_random_shuffle_drs().
.SS "template<typename _IIter > void __gnu_parallel::__shrink (\fBstd::vector\fP< _IIter > & __os_starts, size_t & __count_to_two, size_t & __range_length)"
.PP
Combines two ranges into one and thus halves the number of ranges. \fBParameters:\fP
.RS 4
\fI__os_starts\fP Start positions worked on (oversampled). 
.br
\fI__count_to_two\fP Counts up to 2. 
.br
\fI__range_length\fP Current length of a chunk. 
.RE
.PP

.PP
Definition at line 70 of file list_partition.h.
.PP
References std::vector< _Tp, _Alloc >::size().
.PP
Referenced by __shrink_and_double().
.SS "template<typename _IIter > void __gnu_parallel::__shrink_and_double (\fBstd::vector\fP< _IIter > & __os_starts, size_t & __count_to_two, size_t & __range_length, const bool __make_twice)"
.PP
Shrinks and doubles the ranges. \fBParameters:\fP
.RS 4
\fI__os_starts\fP Start positions worked on (oversampled). 
.br
\fI__count_to_two\fP Counts up to 2. 
.br
\fI__range_length\fP Current length of a chunk. 
.br
\fI__make_twice\fP Whether the \fC__os_starts\fP is allowed to be grown or not 
.RE
.PP

.PP
Definition at line 50 of file list_partition.h.
.PP
References __shrink(), std::vector< _Tp, _Alloc >::resize(), and std::vector< _Tp, _Alloc >::size().
.PP
Referenced by list_partition().
.SS "void __gnu_parallel::__yield ()\fC [inline]\fP"
.PP
Yield the control to another thread, without waiting for the end to the time slice. 
.PP
Definition at line 354 of file parallel/compatibility.h.
.PP
Referenced by __for_each_template_random_access_workstealing(), and __qsb_local_sort_with_helping().
.SS "template<typename _DifferenceType , typename _OutputIterator > _OutputIterator __gnu_parallel::equally_split (_DifferenceType __n, _ThreadIndex __num_threads, _OutputIterator __s)"
.PP
function to split a sequence into parts of almost equal size. The resulting sequence __s of length __num_threads+1 contains the splitting positions when splitting the range [0,__n) into parts of almost equal size (plus minus 1). The first entry is 0, the last one n. There may result empty parts. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements 
.br
\fI__num_threads\fP Number of parts 
.br
\fI__s\fP Splitters 
.RE
.PP
\fBReturns:\fP
.RS 4
End of __splitter sequence, i.e. \fC__s+__num_threads+1\fP 
.RE
.PP

.PP
Definition at line 48 of file equally_split.h.
.PP
Referenced by __determine_samples(), __find_template(), __parallel_partial_sum_linear(), __parallel_unique_copy(), __search_template(), and multiway_merge_exact_splitting().
.SS "template<typename _DifferenceType > _DifferenceType __gnu_parallel::equally_split_point (_DifferenceType __n, _ThreadIndex __num_threads, _ThreadIndex __thread_no)"
.PP
function to split a sequence into parts of almost equal size. Returns the position of the splitting point between thread number __thread_no (included) and thread number __thread_no+1 (excluded). 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements 
.br
\fI__num_threads\fP Number of parts 
.RE
.PP
\fBReturns:\fP
.RS 4
splitting point 
.RE
.PP

.PP
Definition at line 74 of file equally_split.h.
.PP
Referenced by __for_each_template_random_access_ed().
.SS "template<typename _IIter , typename _FunctorType > size_t __gnu_parallel::list_partition (const _IIter __begin, const _IIter __end, _IIter * __starts, size_t * __lengths, const int __num_parts, _FunctorType & __f, int __oversampling = \fC0\fP)"
.PP
Splits a sequence given by input iterators into parts of almost equal size. The function needs only one pass over the sequence. 
.PP
\fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of input sequence. 
.br
\fI__end\fP End iterator of input sequence. 
.br
\fI__starts\fP Start iterators for the resulting parts, dimension \fC__num_parts+1\fP. For convenience, \fC__starts\fP \fC\fP[__num_parts] contains the end iterator of the sequence. 
.br
\fI__lengths\fP Length of the resulting parts. 
.br
\fI__num_parts\fP Number of parts to split the sequence into. 
.br
\fI__f\fP Functor to be applied to each element by traversing __it 
.br
\fI__oversampling\fP Oversampling factor. If 0, then the partitions will differ in at most {{__end} - {__begin}} __elements. Otherwise, the ratio between the longest and the shortest part is bounded by 1/({__oversampling}  {num}) 
.RE
.PP
\fBReturns:\fP
.RS 4
Length of the whole sequence. 
.RE
.PP

.PP
Definition at line 101 of file list_partition.h.
.PP
References __shrink_and_double(), and std::vector< _Tp, _Alloc >::size().
.SS "template<typename _Tp > const _Tp& __gnu_parallel::max (const _Tp & __a, const _Tp & __b)"
.PP
Equivalent to std::max. 
.PP
Definition at line 150 of file parallel/base.h.
.PP
Referenced by __parallel_nth_element(), multiseq_partition(), and multiseq_selection().
.SS "template<typename _Tp > const _Tp& __gnu_parallel::min (const _Tp & __a, const _Tp & __b)"
.PP
Equivalent to std::min. 
.PP
Definition at line 144 of file parallel/base.h.
.PP
Referenced by __for_each_template_random_access_workstealing(), __parallel_sort_qs_divide(), __search_template(), multiseq_partition(), and multiseq_selection().
.SS "template<typename _RanSeqs , typename _RankType , typename _RankIterator , typename _Compare > void __gnu_parallel::multiseq_partition (_RanSeqs __begin_seqs, _RanSeqs __end_seqs, _RankType __rank, _RankIterator __begin_offsets, _Compare __comp = \fC\fBstd::less\fP< typename \fBstd::iterator_traits\fP<typename \fBstd::iterator_traits\fP<_RanSeqs>::value_type:: first_type>::value_type>()\fP)"
.PP
Splits several sorted sequences at a certain global __rank, resulting in a splitting point for each sequence. The sequences are passed via a sequence of random-access iterator pairs, none of the sequences may be empty. If there are several equal elements across the split, the ones on the __left side will be chosen from sequences with smaller number. \fBParameters:\fP
.RS 4
\fI__begin_seqs\fP Begin of the sequence of iterator pairs. 
.br
\fI__end_seqs\fP End of the sequence of iterator pairs. 
.br
\fI__rank\fP The global rank to partition at. 
.br
\fI__begin_offsets\fP A random-access __sequence __begin where the __result will be stored in. Each element of the sequence is an iterator that points to the first element on the greater part of the respective __sequence. 
.br
\fI__comp\fP The ordering functor, defaults to std::less<_Tp>. 
.RE
.PP

.PP
Definition at line 124 of file multiseq_selection.h.
.PP
References __rd_log2(), _GLIBCXX_CALL, std::vector< _Tp, _Alloc >::begin(), std::distance(), __gnu_cxx::distance(), std::priority_queue< _Tp, _Sequence, _Compare >::empty(), std::vector< _Tp, _Alloc >::end(), max(), min(), std::priority_queue< _Tp, _Sequence, _Compare >::pop(), std::priority_queue< _Tp, _Sequence, _Compare >::push(), std::vector< _Tp, _Alloc >::push_back(), and std::priority_queue< _Tp, _Sequence, _Compare >::top().
.PP
Referenced by multiway_merge_exact_splitting().
.SS "template<typename _Tp , typename _RanSeqs , typename _RankType , typename _Compare > _Tp __gnu_parallel::multiseq_selection (_RanSeqs __begin_seqs, _RanSeqs __end_seqs, _RankType __rank, _RankType & __offset, _Compare __comp = \fC\fBstd::less\fP<_Tp>()\fP)"
.PP
Selects the element at a certain global __rank from several sorted sequences. The sequences are passed via a sequence of random-access iterator pairs, none of the sequences may be empty. 
.PP
\fBParameters:\fP
.RS 4
\fI__begin_seqs\fP Begin of the sequence of iterator pairs. 
.br
\fI__end_seqs\fP End of the sequence of iterator pairs. 
.br
\fI__rank\fP The global rank to partition at. 
.br
\fI__offset\fP The rank of the selected element in the global subsequence of elements equal to the selected element. If the selected element is unique, this number is 0. 
.br
\fI__comp\fP The ordering functor, defaults to \fBstd::less\fP. 
.RE
.PP

.PP
Definition at line 390 of file multiseq_selection.h.
.PP
References __rd_log2(), __round_up_to_pow2(), _GLIBCXX_CALL, std::vector< _Tp, _Alloc >::begin(), std::distance(), __gnu_cxx::distance(), std::priority_queue< _Tp, _Sequence, _Compare >::empty(), std::vector< _Tp, _Alloc >::end(), max(), min(), std::priority_queue< _Tp, _Sequence, _Compare >::pop(), std::priority_queue< _Tp, _Sequence, _Compare >::push(), std::vector< _Tp, _Alloc >::push_back(), and std::priority_queue< _Tp, _Sequence, _Compare >::top().
.SS "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut __gnu_parallel::multiway_merge (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::sequential_tag\fP)"
.PP
Multiway Merge Frontend. Merge the sequences specified by seqs_begin and __seqs_end into __target. __seqs_begin and __seqs_end must point to a sequence of pairs. These pairs must contain an iterator to the beginning of a sequence in their first entry and an iterator the _M_end of the same sequence in their second entry.
.PP
Ties are broken arbitrarily. See stable_multiway_merge for a variant that breaks ties by sequence number but is slower.
.PP
The first entries of the pairs (i.e. the begin iterators) will be moved forward.
.PP
The output sequence has to provide enough space for all elements that are written to it.
.PP
This function will merge the input sequences:
.PP
.IP "\(bu" 2
not stable
.IP "\(bu" 2
parallel, depending on the input size and Settings
.IP "\(bu" 2
using sampling for splitting
.IP "\(bu" 2
not using sentinels
.PP
.PP
Example:
.PP
.PP
.nf

   int sequences[10][10];
   for (int __i = 0; __i < 10; ++__i)
     for (int __j = 0; __i < 10; ++__j)
       sequences[__i][__j] = __j;
.fi
.PP
.PP
.PP
.nf
   int __out[33];
   \fBstd::vector\fP<std::pair<int*> > seqs;
   for (int __i = 0; __i < 10; ++__i)
     { seqs.push(std::make_pair<int*>(sequences[__i],
                                      sequences[__i] + 10)) }
.fi
.PP
.PP
.PP
.nf
   multiway_merge(seqs.begin(), seqs.end(), __target, std::less<int>(), 33);
 
.fi
.PP
.PP
\fBSee also:\fP
.RS 4
stable_multiway_merge
.RE
.PP
\fBPrecondition:\fP
.RS 4
All input sequences must be sorted. 
.PP
Target must provide enough space to merge out length elements or the number of elements in all sequences, whichever is smaller.
.RE
.PP
\fBPostcondition:\fP
.RS 4
[__target, return __value) contains merged __elements from the input sequences. 
.PP
return __value - __target = min(__length, number of elements in all sequences).
.RE
.PP
\fBParameters:\fP
.RS 4
\fI_RAIterPairIterator\fP iterator over sequence of pairs of iterators 
.br
\fI_RAIterOut\fP iterator over target sequence 
.br
\fI_DifferenceTp\fP difference type for the sequence 
.br
\fI_Compare\fP strict weak ordering type to compare elements in sequences
.br
\fI__seqs_begin\fP __begin of sequence __sequence 
.br
\fI__seqs_end\fP _M_end of sequence __sequence 
.br
\fI__target\fP target sequence to merge to. 
.br
\fI__comp\fP strict weak ordering to use for element comparison. 
.br
\fI__length\fP Maximum length to merge, possibly larger than the number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
_M_end iterator of output sequence 
.RE
.PP

.PP
Definition at line 1410 of file multiway_merge.h.
.PP
References __sequential_multiway_merge(), and _GLIBCXX_CALL.
.SS "template<template< typename RAI, typename C > class iterator, typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 __gnu_parallel::multiway_merge_3_variant (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _DifferenceTp __length, _Compare __comp)"
.PP
Highly efficient 3-way merging procedure. Merging is done with the algorithm implementation described by Peter Sanders. Basically, the idea is to minimize the number of necessary comparison after merging an element. The implementation trick that makes this fast is that the order of the sequences is stored in the instruction pointer (translated into labels in C++).
.PP
This works well for merging up to 4 sequences.
.PP
Note that making the merging stable does \fInot\fP come at a performance hit.
.PP
Whether the merging is done guarded or unguarded is selected by the used iterator class.
.PP
\fBParameters:\fP
.RS 4
\fI__seqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fI__seqs_end\fP End iterator of iterator pair input sequence. 
.br
\fI__target\fP Begin iterator of output sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__length\fP Maximum length to merge, less equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 234 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL.
.SS "template<template< typename RAI, typename C > class iterator, typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 __gnu_parallel::multiway_merge_4_variant (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _DifferenceTp __length, _Compare __comp)"
.PP
Highly efficient 4-way merging procedure. Merging is done with the algorithm implementation described by Peter Sanders. Basically, the idea is to minimize the number of necessary comparison after merging an element. The implementation trick that makes this fast is that the order of the sequences is stored in the instruction pointer (translated into goto labels in C++).
.PP
This works well for merging up to 4 sequences.
.PP
Note that making the merging stable does \fInot\fP come at a performance hit.
.PP
Whether the merging is done guarded or unguarded is selected by the used iterator class.
.PP
\fBParameters:\fP
.RS 4
\fI__seqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fI__seqs_end\fP End iterator of iterator pair input sequence. 
.br
\fI__target\fP Begin iterator of output sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__length\fP Maximum length to merge, less equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 353 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL.
.SS "template<bool __stable, typename _RAIterIterator , typename _Compare , typename _DifferenceType > void __gnu_parallel::multiway_merge_exact_splitting (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _DifferenceType __length, _DifferenceType __total_length, _Compare __comp, \fBstd::vector\fP< \fBstd::pair\fP< _DifferenceType, _DifferenceType > > * __pieces)"
.PP
Exact splitting for parallel multiway-merge routine. None of the passed sequences may be empty. 
.PP
Definition at line 1112 of file multiway_merge.h.
.PP
References _GLIBCXX_PARALLEL_LENGTH, std::vector< _Tp, _Alloc >::begin(), std::vector< _Tp, _Alloc >::end(), equally_split(), multiseq_partition(), and std::vector< _Tp, _Alloc >::resize().
.PP
Referenced by __parallel_merge_advance().
.SS "template<typename _LT , typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 __gnu_parallel::multiway_merge_loser_tree (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _DifferenceTp __length, _Compare __comp)"
.PP
Multi-way merging procedure for a high branching factor, guarded case. This merging variant uses a LoserTree class as selected by \fC_LT\fP.
.PP
Stability is selected through the used LoserTree class \fC_LT\fP.
.PP
At least one non-empty sequence is required.
.PP
\fBParameters:\fP
.RS 4
\fI__seqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fI__seqs_end\fP End iterator of iterator pair input sequence. 
.br
\fI__target\fP Begin iterator of output sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__length\fP Maximum length to merge, less equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 484 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL, and _GLIBCXX_PARALLEL_LENGTH.
.SS "template<typename UnguardedLoserTree , typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 __gnu_parallel::multiway_merge_loser_tree_sentinel (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< _RAIterIterator >::value_type::first_type >::value_type & __sentinel, _DifferenceTp __length, _Compare __comp)"
.PP
Multi-way merging procedure for a high branching factor, requiring sentinels to exist. \fBParameters:\fP
.RS 4
\fI__stable\fP The value must the same as for the used LoserTrees. 
.br
\fIUnguardedLoserTree\fP _Loser Tree variant to use for the unguarded merging. 
.br
\fIGuardedLoserTree\fP _Loser Tree variant to use for the guarded merging.
.br
\fI__seqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fI__seqs_end\fP End iterator of iterator pair input sequence. 
.br
\fI__target\fP Begin iterator of output sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__length\fP Maximum length to merge, less equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 658 of file multiway_merge.h.
.PP
References __is_sorted(), and _GLIBCXX_CALL.
.SS "template<typename _LT , typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Compare > _RAIter3 __gnu_parallel::multiway_merge_loser_tree_unguarded (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< _RAIterIterator >::value_type::first_type >::value_type & __sentinel, _DifferenceTp __length, _Compare __comp)"
.PP
Multi-way merging procedure for a high branching factor, unguarded case. Merging is done using the LoserTree class \fC_LT\fP.
.PP
Stability is selected by the used LoserTrees.
.PP
\fBPrecondition:\fP
.RS 4
No input will run out of elements during the merge.
.RE
.PP
\fBParameters:\fP
.RS 4
\fI__seqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fI__seqs_end\fP End iterator of iterator pair input sequence. 
.br
\fI__target\fP Begin iterator of output sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__length\fP Maximum length to merge, less equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 567 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL.
.SS "template<bool __stable, typename _RAIterIterator , typename _Compare , typename _DifferenceType > void __gnu_parallel::multiway_merge_sampling_splitting (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _DifferenceType __length, _DifferenceType __total_length, _Compare __comp, \fBstd::vector\fP< \fBstd::pair\fP< _DifferenceType, _DifferenceType > > * __pieces)"
.PP
Sampling based splitting for parallel multiway-merge routine. 
.PP
Definition at line 1032 of file multiway_merge.h.
.PP
References _GLIBCXX_PARALLEL_LENGTH, __gnu_parallel::_Settings::get(), and __gnu_parallel::_Settings::merge_oversampling.
.SS "template<typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare > _RAIterOut __gnu_parallel::multiway_merge_sentinels (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, \fB__gnu_parallel::sequential_tag\fP)"
.PP
Multiway Merge Frontend. Merge the sequences specified by seqs_begin and __seqs_end into __target. __seqs_begin and __seqs_end must point to a sequence of pairs. These pairs must contain an iterator to the beginning of a sequence in their first entry and an iterator the _M_end of the same sequence in their second entry.
.PP
Ties are broken arbitrarily. See stable_multiway_merge for a variant that breaks ties by sequence number but is slower.
.PP
The first entries of the pairs (i.e. the begin iterators) will be moved forward accordingly.
.PP
The output sequence has to provide enough space for all elements that are written to it.
.PP
This function will merge the input sequences:
.PP
.IP "\(bu" 2
not stable
.IP "\(bu" 2
parallel, depending on the input size and Settings
.IP "\(bu" 2
using sampling for splitting
.IP "\(bu" 2
using sentinels
.PP
.PP
You have to take care that the element the _M_end iterator points to is readable and contains a value that is greater than any other non-sentinel value in all sequences.
.PP
Example:
.PP
.PP
.nf

   int sequences[10][11];
   for (int __i = 0; __i < 10; ++__i)
     for (int __j = 0; __i < 11; ++__j)
       sequences[__i][__j] = __j; // __last one is sentinel!
.fi
.PP
.PP
.PP
.nf
   int __out[33];
   \fBstd::vector\fP<std::pair<int*> > seqs;
   for (int __i = 0; __i < 10; ++__i)
     { seqs.push(std::make_pair<int*>(sequences[__i],
                                      sequences[__i] + 10)) }
.fi
.PP
.PP
.PP
.nf
   multiway_merge(seqs.begin(), seqs.end(), __target, std::less<int>(), 33);
 
.fi
.PP
.PP
\fBPrecondition:\fP
.RS 4
All input sequences must be sorted. 
.PP
Target must provide enough space to merge out length elements or the number of elements in all sequences, whichever is smaller. 
.PP
For each \fC__i\fP, \fC__seqs_begin\fP[__i].second must be the end marker of the sequence, but also reference the one more __sentinel element.
.RE
.PP
\fBPostcondition:\fP
.RS 4
[__target, return __value) contains merged __elements from the input sequences. 
.PP
return __value - __target = min(__length, number of elements in all sequences).
.RE
.PP
\fBSee also:\fP
.RS 4
stable_multiway_merge_sentinels
.RE
.PP
\fBParameters:\fP
.RS 4
\fI_RAIterPairIterator\fP iterator over sequence of pairs of iterators 
.br
\fI_RAIterOut\fP iterator over target sequence 
.br
\fI_DifferenceTp\fP difference type for the sequence 
.br
\fI_Compare\fP strict weak ordering type to compare elements in sequences
.br
\fI__seqs_begin\fP __begin of sequence __sequence 
.br
\fI__seqs_end\fP _M_end of sequence __sequence 
.br
\fI__target\fP target sequence to merge to. 
.br
\fI__comp\fP strict weak ordering to use for element comparison. 
.br
\fI__length\fP Maximum length to merge, possibly larger than the number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
_M_end iterator of output sequence 
.RE
.PP

.PP
Definition at line 1774 of file multiway_merge.h.
.PP
References __sequential_multiway_merge(), and _GLIBCXX_CALL.
.SS "template<bool __stable, bool __sentinels, typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename _Splitter , typename _Compare > _RAIter3 __gnu_parallel::parallel_multiway_merge (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _Splitter __splitter, _DifferenceTp __length, _Compare __comp, _ThreadIndex __num_threads)"
.PP
Parallel multi-way merge routine. The _GLIBCXX_PARALLEL_DECISION is based on the branching factor and runtime settings.
.PP
Must not be called if the number of sequences is 1.
.PP
\fBParameters:\fP
.RS 4
\fI_Splitter\fP functor to split input (either __exact or sampling based)
.br
\fI__seqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fI__seqs_end\fP End iterator of iterator pair input sequence. 
.br
\fI__target\fP Begin iterator of output sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__length\fP Maximum length to merge, possibly larger than the number of elements available. 
.br
\fI__stable\fP Stable merging incurs a performance penalty. 
.br
\fI__sentinel\fP Ignored. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 1217 of file multiway_merge.h.
.PP
References __is_sorted(), _GLIBCXX_CALL, _GLIBCXX_PARALLEL_LENGTH, __gnu_parallel::_Settings::get(), and __gnu_parallel::_Settings::merge_oversampling.
.PP
Referenced by __parallel_merge_advance().
.SS "template<bool __stable, bool __exact, typename _RAIter , typename _Compare > void __gnu_parallel::parallel_sort_mwms (_RAIter __begin, _RAIter __end, _Compare __comp, _ThreadIndex __num_threads)"
.PP
PMWMS main call. \fBParameters:\fP
.RS 4
\fI__begin\fP Begin iterator of sequence. 
.br
\fI__end\fP End iterator of sequence. 
.br
\fI__comp\fP Comparator. 
.br
\fI__n\fP Length of sequence. 
.br
\fI__num_threads\fP Number of threads to use. 
.RE
.PP

.PP
Definition at line 394 of file multiway_mergesort.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_num_threads, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_offsets, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_pieces, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_samples, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_source, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_starts, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_temporary, __gnu_parallel::_Settings::get(), std::vector< _Tp, _Alloc >::resize(), and __gnu_parallel::_Settings::sort_mwms_oversampling.
.SS "template<bool __stable, bool __exact, typename _RAIter , typename _Compare > void __gnu_parallel::parallel_sort_mwms_pu (_PMWMSSortingData< _RAIter > * __sd, _Compare & __comp)"
.PP
PMWMS code executed by each thread. \fBParameters:\fP
.RS 4
\fI__sd\fP Pointer to algorithm data. 
.br
\fI__comp\fP Comparator. 
.RE
.PP

.PP
Definition at line 308 of file multiway_mergesort.h.
.PP
References __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_num_threads, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_pieces, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_source, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_starts, __gnu_parallel::_PMWMSSortingData< _RAIter >::_M_temporary, __gnu_parallel::_Settings::get(), __gnu_parallel::_Settings::sort_mwms_oversampling, and std::uninitialized_copy().
.SH "Variable Documentation"
.PP 
.SS "const int \fB__gnu_parallel::_CASable_bits\fP\fC [static]\fP"
.PP
Number of bits of _CASable. 
.PP
Definition at line 130 of file types.h.
.PP
Referenced by __decode2(), and __encode2().
.SS "const \fB_CASable\fP \fB__gnu_parallel::_CASable_mask\fP\fC [static]\fP"
.PP
\fB_CASable\fP with the right half of bits set to 1. 
.PP
Definition at line 133 of file types.h.
.PP
Referenced by __decode2().
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
